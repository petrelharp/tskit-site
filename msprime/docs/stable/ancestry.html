
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ancestry simulations &#8212; Msprime manual</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Mutation simulations" href="mutations.html" />
    <link rel="prev" title="Installation" href="installation.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      <h1 class="site-logo" id="site-title">Msprime manual</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Introduction
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="quickstart.html">
   Quickstart
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="installation.html">
   Installation
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Running simulations
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Ancestry simulations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mutations.html">
   Mutation simulations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="demography.html">
   Demographic models
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="replication.html">
   Randomness and replication
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Interfaces
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="api.html">
   API Reference
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cli.html">
   Command line interface
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Utilities
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="rate_maps.html">
   Rate Maps
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihoods.html">
   Computing likelihoods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="logging.html">
   Logging
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Miscellaneous
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="legacy.html">
   Legacy (version 0.x) APIs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="switch_from_other_simulators.html">
   Switching from other simulators
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="development.html">
   Development
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="CITATION.html">
   Citing msprime
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="CHANGELOG.html">
   Changelog
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  msprime 1.0.1
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="_sources/ancestry.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/ancestry.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/tskit-dev/msprime"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/tskit-dev/msprime/issues/new?title=Issue%20on%20page%20%2Fancestry.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/tskit-dev/msprime/edit/main/docs/ancestry.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#quick-reference">
   Quick reference
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#specifying-samples">
   Specifying samples
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#populations">
     Populations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sampling-time">
     Sampling time
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sample-details">
     Sample details
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#demography">
   Demography
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ploidy">
   Ploidy
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#default-number-of-nodes-per-sample-individual">
     Default number of nodes per sample individual
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#coalescent-time-scales">
     Coalescent time scales
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#genome-properties">
   Genome properties
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sequence-length">
     Sequence length
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#recombination">
     Recombination
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#gene-conversion">
     Gene conversion
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#discrete-or-continuous">
     Discrete or continuous?
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multiple-chromosomes">
     Multiple chromosomes
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#do-i-need-to-do-this">
       Do I need to do this?
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#example">
       Example
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#recording-more-information">
   Recording more information
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ancestral-recombination-graph">
     Ancestral recombination graph
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#migration-events">
     Migration events
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#census-events">
     Census events
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#using-the-dtwf-model">
       Using the DTWF model
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#manipulating-simulation-time">
   Manipulating simulation time
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#stopping-simulations-early">
     Stopping simulations early
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#setting-the-start-time">
     Setting the start time
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#order-of-event-execution">
     Order of event execution
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#specifying-the-initial-state">
   Specifying the initial state
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#combining-backward-time-simulations">
     Combining backward-time simulations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#interaction-with-demography">
     Interaction with demography
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#continuing-forwards-time-simulations-recapitating">
     Continuing forwards-time simulations (“recapitating”)
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#models">
   Models
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#specifying-ancestry-models">
     Specifying ancestry models
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#single-models">
       Single models
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#model-duration">
       Model duration
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#model-completion">
       Model completion
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#multiple-models">
       Multiple models
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hudson-coalescent">
     Hudson coalescent
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#smc-approximations">
     SMC approximations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#discrete-time-wright-fisher">
     Discrete Time Wright-Fisher
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multiple-merger-coalescents">
     Multiple merger coalescents
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#selective-sweeps">
     Selective sweeps
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#hard-sweeps">
       Hard sweeps
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#multiple-sweeps">
       Multiple sweeps
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#missing-data">
   Missing data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#common-errors">
   Common errors
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#infinite-waiting-time">
     Infinite waiting time
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="ancestry-simulations">
<span id="sec-ancestry"></span><h1>Ancestry simulations<a class="headerlink" href="#ancestry-simulations" title="Permalink to this headline">¶</a></h1>
<p>Msprime simulates the ancestry of sampled genomes under a number of
different backwards-in-time population genetic
<a class="reference internal" href="#sec-ancestry-models"><span class="std std-ref">models</span></a>. The simulated ancestry is
represented as a <a class="reference external" href="https://tskit.dev">succinct tree sequence</a> using
the <a class="reference external" href="https://tskit.dev/tskit">tskit</a> library, which provides an
extensive suite of operations for analysing genealogical trees
and DNA sequence data. See the <a class="reference external" href="https://tskit.dev/tutorials/getting_started.html#sec-tskit-getting-started" title="(in Python)"><span>Getting started with tskit</span></a>
tutorial for more information on how to process data using tskit.</p>
<p>Here we run a simple simulation and show a summary of the resulting
tree sequence:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<div>
  <style>
    .tskit-table thead tr th {text-align: left;padding: 0.5em 0.5em;}
    .tskit-table tbody tr td {padding: 0.5em 0.5em;}
    .tskit-table tbody tr td:first-of-type {text-align: left;}
    .tskit-details-label {vertical-align: top; padding-right:5px;}
    .tskit-table-set {display: inline-flex;flex-wrap: wrap;margin: -12px 0 0 -12px;width: calc(100% + 12px);}
    .tskit-table-set-table {margin: 12px 0 0 12px;}
    details {display: inline-block;}
    summary {cursor: pointer; outline: 0; display: list-item;}
  </style>
  <div class="tskit-table-set">
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="padding:0;line-height:21px;">
              <img style="height: 32px;display: inline-block;padding: 3px 5px 3px 0;"src="https://raw.githubusercontent.com/tskit-dev/administrative/main/tskit_logo.svg"/>
              <a target="_blank" href="https://tskit.readthedocs.io/en/latest/python-api.html#the-treesequence-class"> Tree Sequence
            </th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Trees</td><td>1</td></tr>
          <tr><td>Sequence Length</td><td>1.0</td></tr>
          <tr><td>Sample Nodes</td><td>4</td></tr>
          <tr><td>Total Size</td><td>1.6 KiB</td></tr>
          <tr>
            <td>Metadata</td><td style="text-align: left;">No Metadata</td></tr>
        </tbody>
      </table>
    </div>
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="line-height:21px;">Table</th>
            <th>Rows</th>
            <th>Size</th>
            <th>Has Metadata</th>
          </tr>
        </thead>
        <tbody>

      <tr>
        <td>Edges</td>
          <td>6</td>
          <td>172 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Individuals</td>
          <td>2</td>
          <td>44 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Migrations</td>
          <td>0</td>
          <td>4 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Mutations</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Nodes</td>
          <td>7</td>
          <td>172 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Populations</td>
          <td>1</td>
          <td>216 Bytes</td>
          <td style="text-align: center;">
            ✅
          </td>
        </tr>

      <tr>
        <td>Provenances</td>
          <td>1</td>
          <td>956 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Sites</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>
</div>
</div></div>
</div>
<p>The <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a> function has many parameters to specify
the details of the simulations. The <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">API</span> <span class="pre">documentation</span></code></a>
contains a precise description of the parameter; the sections
in this page provide some explanation and examples of how to use these
parameters.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It’s important to note that <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a> only simulates
the ancestral trees for samples: if we want actual sequence data
then we also need to simulate mutations on these trees.
See the <a class="reference internal" href="mutations.html#sec-mutations"><span class="std std-ref">Mutation simulations</span></a> section for more information on how to do
this.</p>
</div>
<hr class="docutils" />
<div class="section" id="quick-reference">
<span id="sec-ancestry-quickref"></span><h2>Quick reference<a class="headerlink" href="#quick-reference" title="Permalink to this headline">¶</a></h2>
<dl class="simple myst">
<dt><a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a></dt><dd><p>Simulate ancestral tree sequence topology</p>
</dd>
</dl>
<p><strong>Models</strong></p>
<dl class="simple myst">
<dt><a class="reference internal" href="api.html#msprime.StandardCoalescent" title="msprime.StandardCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardCoalescent</span></code></a></dt><dd><p>Coalescent with recombination (“hudson”)</p>
</dd>
<dt><a class="reference internal" href="api.html#msprime.SmcApproxCoalescent" title="msprime.SmcApproxCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">SmcApproxCoalescent</span></code></a></dt><dd><p>Sequentially Markov Coalescent (“smc”)</p>
</dd>
<dt><a class="reference internal" href="api.html#msprime.SmcPrimeApproxCoalescent" title="msprime.SmcPrimeApproxCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">SmcPrimeApproxCoalescent</span></code></a></dt><dd><p>SMC’(“smc_prime”)</p>
</dd>
<dt><a class="reference internal" href="api.html#msprime.DiscreteTimeWrightFisher" title="msprime.DiscreteTimeWrightFisher"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeWrightFisher</span></code></a></dt><dd><p>Generation-by-generation Wright-Fisher</p>
</dd>
<dt><a class="reference internal" href="api.html#msprime.BetaCoalescent" title="msprime.BetaCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">BetaCoalescent</span></code></a></dt><dd><p>Beta coalescent multiple-merger</p>
</dd>
<dt><a class="reference internal" href="api.html#msprime.DiracCoalescent" title="msprime.DiracCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiracCoalescent</span></code></a></dt><dd><p>Dirac coalescent multiple-merger</p>
</dd>
<dt><a class="reference internal" href="api.html#msprime.SweepGenicSelection" title="msprime.SweepGenicSelection"><code class="xref py py-class docutils literal notranslate"><span class="pre">SweepGenicSelection</span></code></a></dt><dd><p>Selective sweep at a linked locus</p>
</dd>
</dl>
<hr class="docutils" />
</div>
<div class="section" id="specifying-samples">
<span id="sec-ancestry-samples"></span><h2>Specifying samples<a class="headerlink" href="#specifying-samples" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">samples</span></code> argument to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a> defines the number
of sampled individuals whose history will be simulated. There are three different
forms; the <code class="docutils literal notranslate"><span class="pre">samples</span></code> argument can be:</p>
<ul class="simple">
<li><p>an <strong>integer</strong>, interpreted as the number of sampled individuals to draw in
a single population model;</p></li>
<li><p>a <strong>dictionary</strong> mapping population references (either integer IDs or
names) to the number of sampled individuals for that population;</p></li>
<li><p>a list of <a class="reference internal" href="api.html#msprime.SampleSet" title="msprime.SampleSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleSet</span></code></a> objects, which provide more flexibility
in how groups of similar samples are drawn from populations.</p></li>
</ul>
<p>In the simplest case, provide a single integer which defines the number
of samples:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">ts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<div>
  <style>
    .tskit-table thead tr th {text-align: left;padding: 0.5em 0.5em;}
    .tskit-table tbody tr td {padding: 0.5em 0.5em;}
    .tskit-table tbody tr td:first-of-type {text-align: left;}
    .tskit-details-label {vertical-align: top; padding-right:5px;}
    .tskit-table-set {display: inline-flex;flex-wrap: wrap;margin: -12px 0 0 -12px;width: calc(100% + 12px);}
    .tskit-table-set-table {margin: 12px 0 0 12px;}
    details {display: inline-block;}
    summary {cursor: pointer; outline: 0; display: list-item;}
  </style>
  <div class="tskit-table-set">
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="padding:0;line-height:21px;">
              <img style="height: 32px;display: inline-block;padding: 3px 5px 3px 0;"src="https://raw.githubusercontent.com/tskit-dev/administrative/main/tskit_logo.svg"/>
              <a target="_blank" href="https://tskit.readthedocs.io/en/latest/python-api.html#the-treesequence-class"> Tree Sequence
            </th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Trees</td><td>1</td></tr>
          <tr><td>Sequence Length</td><td>1.0</td></tr>
          <tr><td>Sample Nodes</td><td>4</td></tr>
          <tr><td>Total Size</td><td>1.6 KiB</td></tr>
          <tr>
            <td>Metadata</td><td style="text-align: left;">No Metadata</td></tr>
        </tbody>
      </table>
    </div>
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="line-height:21px;">Table</th>
            <th>Rows</th>
            <th>Size</th>
            <th>Has Metadata</th>
          </tr>
        </thead>
        <tbody>

      <tr>
        <td>Edges</td>
          <td>6</td>
          <td>172 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Individuals</td>
          <td>2</td>
          <td>44 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Migrations</td>
          <td>0</td>
          <td>4 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Mutations</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Nodes</td>
          <td>7</td>
          <td>172 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Populations</td>
          <td>1</td>
          <td>216 Bytes</td>
          <td style="text-align: center;">
            ✅
          </td>
        </tr>

      <tr>
        <td>Provenances</td>
          <td>1</td>
          <td>950 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Sites</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>
</div>
</div></div>
</div>
<p>Here we specify two sample <strong>individuals</strong>, which at the default
ploidy of two, gives us four sample <strong>nodes</strong>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is important to note that the number of samples
refers to the number of <em>individuals</em> not the number of <em>nodes</em>
(monoploid genomes). See the <a class="reference internal" href="#sec-ancestry-ploidy"><span class="std std-ref">Ploidy</span></a>
section for details.</p>
</div>
<p>This integer form for the <code class="docutils literal notranslate"><span class="pre">samples</span></code> argument can only be used
when the <code class="docutils literal notranslate"><span class="pre">demography</span></code> is a single population model.</p>
<div class="section" id="populations">
<h3>Populations<a class="headerlink" href="#populations" title="Permalink to this headline">¶</a></h3>
<p>The next example illustrates one usage of the dictionary form of the <code class="docutils literal notranslate"><span class="pre">samples</span></code>
argument, in which the keys refer to populations in the
<a class="reference internal" href="demography.html#sec-demography"><span class="std std-ref">demographic model</span></a> and
the values are the number of samples to draw.
(See the <a class="reference internal" href="#sec-ancestry-demography"><span class="std std-ref">Demography</span></a> section for more details on
the <code class="docutils literal notranslate"><span class="pre">demography</span></code> argument to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a>.)
We first create a <a class="reference internal" href="api.html#msprime.Demography" title="msprime.Demography"><code class="xref py py-class docutils literal notranslate"><span class="pre">Demography</span></code></a> object representing
a 10 deme linear stepping stone model. Then, we run the simulation
with 3 diploid samples each drawn from the first and last demes in this
linear habitat.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">stepping_stone_model</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span>
    <span class="n">migration_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">boundaries</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">)</span>
<span class="n">ts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<div>
  <style>
    .tskit-table thead tr th {text-align: left;padding: 0.5em 0.5em;}
    .tskit-table tbody tr td {padding: 0.5em 0.5em;}
    .tskit-table tbody tr td:first-of-type {text-align: left;}
    .tskit-details-label {vertical-align: top; padding-right:5px;}
    .tskit-table-set {display: inline-flex;flex-wrap: wrap;margin: -12px 0 0 -12px;width: calc(100% + 12px);}
    .tskit-table-set-table {margin: 12px 0 0 12px;}
    details {display: inline-block;}
    summary {cursor: pointer; outline: 0; display: list-item;}
  </style>
  <div class="tskit-table-set">
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="padding:0;line-height:21px;">
              <img style="height: 32px;display: inline-block;padding: 3px 5px 3px 0;"src="https://raw.githubusercontent.com/tskit-dev/administrative/main/tskit_logo.svg"/>
              <a target="_blank" href="https://tskit.readthedocs.io/en/latest/python-api.html#the-treesequence-class"> Tree Sequence
            </th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Trees</td><td>1</td></tr>
          <tr><td>Sequence Length</td><td>1.0</td></tr>
          <tr><td>Sample Nodes</td><td>12</td></tr>
          <tr><td>Total Size</td><td>5.2 KiB</td></tr>
          <tr>
            <td>Metadata</td><td style="text-align: left;">No Metadata</td></tr>
        </tbody>
      </table>
    </div>
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="line-height:21px;">Table</th>
            <th>Rows</th>
            <th>Size</th>
            <th>Has Metadata</th>
          </tr>
        </thead>
        <tbody>

      <tr>
        <td>Edges</td>
          <td>22</td>
          <td>620 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Individuals</td>
          <td>6</td>
          <td>108 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Migrations</td>
          <td>0</td>
          <td>4 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Mutations</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Nodes</td>
          <td>23</td>
          <td>556 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Populations</td>
          <td>10</td>
          <td>549 Bytes</td>
          <td style="text-align: center;">
            ✅
          </td>
        </tr>

      <tr>
        <td>Provenances</td>
          <td>1</td>
          <td>3.2 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Sites</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>
</div>
</div></div>
</div>
<p>The keys in the dictionary can also be the string names of the
population (see the <a class="reference internal" href="demography.html#sec-demography-populations-identifiers"><span class="std std-ref">Identifying populations</span></a> section
), which is useful when we are simulating from empirically
estimated models. For example, here create a <a class="reference internal" href="api.html#msprime.Demography" title="msprime.Demography"><code class="xref py py-class docutils literal notranslate"><span class="pre">Demography</span></code></a> object
based on a species tree, and then draw samples using the species names.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">from_species_tree</span><span class="p">(</span>
    <span class="s2">&quot;(((human:5.6,chimpanzee:5.6):3.0,gorilla:8.6):9.4,orangutan:18.0)&quot;</span><span class="p">,</span>
    <span class="n">time_units</span><span class="o">=</span><span class="s2">&quot;myr&quot;</span><span class="p">,</span>
    <span class="n">initial_size</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">generation_time</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">({</span><span class="s2">&quot;gorilla&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;human&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">)</span>
<span class="n">ts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<div>
  <style>
    .tskit-table thead tr th {text-align: left;padding: 0.5em 0.5em;}
    .tskit-table tbody tr td {padding: 0.5em 0.5em;}
    .tskit-table tbody tr td:first-of-type {text-align: left;}
    .tskit-details-label {vertical-align: top; padding-right:5px;}
    .tskit-table-set {display: inline-flex;flex-wrap: wrap;margin: -12px 0 0 -12px;width: calc(100% + 12px);}
    .tskit-table-set-table {margin: 12px 0 0 12px;}
    details {display: inline-block;}
    summary {cursor: pointer; outline: 0; display: list-item;}
  </style>
  <div class="tskit-table-set">
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="padding:0;line-height:21px;">
              <img style="height: 32px;display: inline-block;padding: 3px 5px 3px 0;"src="https://raw.githubusercontent.com/tskit-dev/administrative/main/tskit_logo.svg"/>
              <a target="_blank" href="https://tskit.readthedocs.io/en/latest/python-api.html#the-treesequence-class"> Tree Sequence
            </th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Trees</td><td>1</td></tr>
          <tr><td>Sequence Length</td><td>1.0</td></tr>
          <tr><td>Sample Nodes</td><td>12</td></tr>
          <tr><td>Total Size</td><td>4.6 KiB</td></tr>
          <tr>
            <td>Metadata</td><td style="text-align: left;">No Metadata</td></tr>
        </tbody>
      </table>
    </div>
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="line-height:21px;">Table</th>
            <th>Rows</th>
            <th>Size</th>
            <th>Has Metadata</th>
          </tr>
        </thead>
        <tbody>

      <tr>
        <td>Edges</td>
          <td>22</td>
          <td>620 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Individuals</td>
          <td>6</td>
          <td>108 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Migrations</td>
          <td>0</td>
          <td>4 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Mutations</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Nodes</td>
          <td>23</td>
          <td>556 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Populations</td>
          <td>7</td>
          <td>449 Bytes</td>
          <td style="text-align: center;">
            ✅
          </td>
        </tr>

      <tr>
        <td>Provenances</td>
          <td>1</td>
          <td>2.7 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Sites</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>
</div>
</div></div>
</div>
<p>When samples are drawn using this dictionary form it is always
at the population’s <a class="reference internal" href="demography.html#sec-demography-populations-default-sampling-time"><span class="std std-ref">Default sampling time</span></a>.
If you wish to draw samples at a different time, then you must use the
more general form of a list of <a class="reference internal" href="api.html#msprime.SampleSet" title="msprime.SampleSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleSet</span></code></a> objects.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the <a class="reference internal" href="#sec-ancestry-demography"><span class="std std-ref">Demography</span></a> section for more information
on how to specify demographic models in a simulation.</p>
</div>
</div>
<div class="section" id="sampling-time">
<span id="sec-ancestry-samples-sampling-time"></span><h3>Sampling time<a class="headerlink" href="#sampling-time" title="Permalink to this headline">¶</a></h3>
<p>By default the samples that we draw from a <a class="reference internal" href="api.html#msprime.Population" title="msprime.Population"><code class="xref py py-class docutils literal notranslate"><span class="pre">Population</span></code></a> are
at the population’s <a class="reference internal" href="api.html#msprime.Population.default_sampling_time" title="msprime.Population.default_sampling_time"><code class="xref py py-attr docutils literal notranslate"><span class="pre">default_sampling_time</span></code></a>.
See the <a class="reference internal" href="demography.html#sec-demography-populations-default-sampling-time"><span class="std std-ref">Default sampling time</span></a>
section for more information about how this is
set for populations in a demographic model.</p>
<p>We can manually control the time at which samples
are drawn using list of <a class="reference internal" href="api.html#msprime.SampleSet" title="msprime.SampleSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleSet</span></code></a> objects form for the
samples argument.</p>
<p>In this example we create two diploid sample individuals,
one at the present time
and one taken 50 generations ago, representing one modern
and one ancient individual. By default, when we draw the
trees, the nodes that belong to samples are drawn as squares
whereas nodes that are not samples are drawn as circles.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="p">],</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span>
<span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_10_0.svg" src="_images/ancestry_10_0.svg" /></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the <a class="reference internal" href="#sec-ancestry-event-order"><span class="std std-ref">Order of event execution</span></a> section for details
of the relative order in which sampling events occur.</p>
</div>
</div>
<div class="section" id="sample-details">
<span id="sec-ancestry-samples-sampling-details"></span><h3>Sample details<a class="headerlink" href="#sample-details" title="Permalink to this headline">¶</a></h3>
<p>Sample individuals and nodes are allocated sequentially in the order that
they are specified. For example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">island_model</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">migration_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="mi">0</span><span class="p">)],</span>
    <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>id	flags	location	parents	metadata
0	0			
1	0			
2	0			
id	flags	population	individual	time	metadata
0	1	1	0	0.00000000000000	
1	1	1	0	0.00000000000000	
2	1	0	1	0.00000000000000	
3	1	0	1	0.00000000000000	
4	1	0	2	0.00000000000000	
5	1	0	2	0.00000000000000	
</pre></div>
</div>
</div>
</div>
<p>(Because we’re only interested in the sampled nodes and individuals we
stopped the simulation from actually doing anything by setting
<code class="docutils literal notranslate"><span class="pre">end_time=0</span></code> — see the <a class="reference internal" href="#sec-ancestry-start-time"><span class="std std-ref">Setting the start time</span></a> section
for more information.) Here we define three sample individuals,
and we therefore have three rows in the individual table.
Because these are diploid individuals, the node table contains
six sample nodes. If we look at the <code class="docutils literal notranslate"><span class="pre">individual</span></code> column in the
node table we can see that the first two nodes correspond to individual
<code class="docutils literal notranslate"><span class="pre">0</span></code>, the next two nodes individual <code class="docutils literal notranslate"><span class="pre">1</span></code>, etc. The sample configuration
stated that the first sample should come from population <code class="docutils literal notranslate"><span class="pre">1</span></code> and
the other two from population <code class="docutils literal notranslate"><span class="pre">0</span></code>, and we can see this reflected
in the <code class="docutils literal notranslate"><span class="pre">population</span></code> column of the node table. (Somewhat confusingly,
population values are associated with nodes rather than individuals;
this is mostly for historical reasons.)</p>
<p>The <a class="reference internal" href="api.html#msprime.SampleSet" title="msprime.SampleSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleSet</span></code></a> class has a number of attributes which default
to <code class="docutils literal notranslate"><span class="pre">None</span></code>. If these are set they will <strong>override</strong> the values
which might be specified elsewhere. For example, we can specify
mixed ploidy samples via the <code class="docutils literal notranslate"><span class="pre">ploidy</span></code> attribute of <a class="reference internal" href="api.html#msprime.SampleSet" title="msprime.SampleSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleSet</span></code></a>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span>
    <span class="n">ploidy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>id	flags	location	parents	metadata
0	0			
1	0			
2	0			
id	flags	population	individual	time	metadata
0	1	0	0	0.00000000000000	
1	1	0	0	0.00000000000000	
2	1	0	0	0.00000000000000	
3	1	0	1	0.00000000000000	
4	1	0	2	0.00000000000000	
</pre></div>
</div>
</div>
</div>
<p>(Again, we stop the simulation immediately because we’re only interested
in the initial samples.) Here we have three sampled individuals again
but in this they are mixed ploidy: the first individual is triploid
and the other two are haploid.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is vital to note that setting the <code class="docutils literal notranslate"><span class="pre">ploidy</span></code> value
of <a class="reference internal" href="api.html#msprime.SampleSet" title="msprime.SampleSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleSet</span></code></a> objects only affects sampling and does
not affect the actual simulation. In this case, the simulation
will be run on the haploid time scale.  See the
<a class="reference internal" href="#sec-ancestry-ploidy"><span class="std std-ref">Ploidy</span></a> section for more details.</p>
</div>
<p>If you wish to set up the node and individual IDs in some other way,
it is possible to do so by using the <code class="docutils literal notranslate"><span class="pre">initial_state</span></code> parameter.
See the  <a class="reference internal" href="#sec-ancestry-initial-state"><span class="std std-ref">Specifying the initial state</span></a> for more information
on how to use this (advanced) feature.</p>
</div>
</div>
<div class="section" id="demography">
<span id="sec-ancestry-demography"></span><h2>Demography<a class="headerlink" href="#demography" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="demography.html#sec-demography"><span class="std std-ref">demographic model</span></a> is a description of a
set of populations, the migration rates between then and the
events that modify the populations over time. Ancestry simulations
can take one of these models as input via the <code class="docutils literal notranslate"><span class="pre">demography</span></code>
parameter to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Please see the <a class="reference internal" href="demography.html#sec-demography"><span class="std std-ref">Demographic models</span></a> section for details on how
to create and debug demographic models, and the
<a class="reference internal" href="#sec-ancestry-samples"><span class="std std-ref">Specifying samples</span></a> section for help on how to
define the locations and times of sampled individuals.</p>
</div>
<p>We don’t need to explicitly specify a <a class="reference internal" href="api.html#msprime.Demography" title="msprime.Demography"><code class="xref py py-class docutils literal notranslate"><span class="pre">Demography</span></code></a>
for every ancestry simulation, however. By default, we assume a
single fixed-size population. For the default
<a class="reference internal" href="#sec-ancestry-models-hudson"><span class="std std-ref">standard coalescent</span></a> ancestry
model we assume a population size of 1, so that time is measured
in “coalescent units”. This is useful for theoretical work where
we usually work in scaled coalescent time.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>By default msprime uses the <strong>diploid</strong> coalescent time scale;
see the <a class="reference internal" href="#sec-ancestry-ploidy"><span class="std std-ref">Ploidy</span></a> section for more details.</p>
</div>
<p>Outside of theoretical analysis, working with scaled
coalescent time can be confusing and it’s usually better to
explicitly set the population size so that the output
times are directly interpretable in generations.
The <code class="docutils literal notranslate"><span class="pre">population_size</span></code> parameter to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a>
allows us to set the size of the single constant
sized population in the default demography.</p>
<p>For example, here we run the same simulation twice, one with
the default population size and one with a population size
of 100:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_16_0.svg" src="_images/ancestry_16_0.svg" /></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_17_0.svg" src="_images/ancestry_17_0.svg" /></div>
</div>
<p>We can see that the results are identical, except the node times have
been scaled by the population size.</p>
<p>The <a class="reference internal" href="#sec-ancestry-models-dtwf"><span class="std std-ref">Discrete Time Wright-Fisher</span></a> model is different. Because it
explicitly works with a population of N individuals we get an
error if we don’t specify a population size:</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ValueError</span><span class="g g-Whitespace">                                </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">3</span><span class="n">cbdc35a974a</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">sim_ancestry</span><span class="nt">(samples, demography, sequence_length, discrete_genome, recombination_rate, gene_conversion_rate, gene_conversion_tract_length, population_size, ploidy, model, initial_state, start_time, end_time, record_migrations, record_full_arg, num_labels, random_seed, num_replicates, replicate_index, record_provenance)</span>
<span class="g g-Whitespace">   </span><span class="mi">1145</span>         <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
<span class="g g-Whitespace">   </span><span class="mi">1146</span>         <span class="n">provenance_dict</span> <span class="o">=</span> <span class="n">_build_provenance</span><span class="p">(</span><span class="s2">&quot;sim_ancestry&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
<span class="ne">-&gt; </span><span class="mi">1147</span>     <span class="n">sim</span> <span class="o">=</span> <span class="n">_parse_sim_ancestry</span><span class="p">(</span>
<span class="g g-Whitespace">   </span><span class="mi">1148</span>         <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1149</span>         <span class="n">sequence_length</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">_parse_sim_ancestry</span><span class="nt">(samples, sequence_length, recombination_rate, gene_conversion_rate, gene_conversion_tract_length, discrete_genome, population_size, demography, ploidy, model, initial_state, start_time, end_time, record_migrations, record_full_arg, num_labels, random_seed, init_for_debugger)</span>
<span class="g g-Whitespace">    </span><span class="mi">898</span>             <span class="c1"># an error.</span>
<span class="g g-Whitespace">    </span><span class="mi">899</span>             <span class="k">if</span> <span class="n">population_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">900</span>                 <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">901</span>                     <span class="s2">&quot;When using the DTWF model, the population size must be set &quot;</span>
<span class="g g-Whitespace">    </span><span class="mi">902</span>                     <span class="s2">&quot;explicitly, either using the population_size or demography &quot;</span>

<span class="ne">ValueError</span>: When using the DTWF model, the population size must be set explicitly, either using the population_size or demography arguments.
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because the DTWF models populations of individuals rather than
using continuous
time approximations, simulations with different population sizes
will yield entirely different results; we are <strong>not</strong> simply
rescaling time by using different population sizes. Furthermore,
simulations with large population sizes will take relatively
more CPU time and memory.</p>
</div>
<hr class="docutils" />
</div>
<div class="section" id="ploidy">
<span id="sec-ancestry-ploidy"></span><h2>Ploidy<a class="headerlink" href="#ploidy" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">ploidy</span></code> argument to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a> has two effects:</p>
<ol class="simple">
<li><p>It sets the default ploidy (i.e., number sample nodes) of sample
individuals.</p></li>
<li><p>For continuous time coalescent models, it sets the time scale.</p></li>
</ol>
<p>Both of these are somewhat confusing, so let’s look at them one at a time.</p>
<div class="section" id="default-number-of-nodes-per-sample-individual">
<span id="sec-ancestry-ploidy-default-num-nodes"></span><h3>Default number of nodes per sample individual<a class="headerlink" href="#default-number-of-nodes-per-sample-individual" title="Permalink to this headline">¶</a></h3>
<p>As discussed in the <a class="reference internal" href="#sec-ancestry-samples-sampling-details"><span class="std std-ref">Sample details</span></a> section,
the number of nodes (i.e., monoploid genomes) that we allocate per
sample individual is determined by the ploidy. Here, we specify
2 sample individuals with a ploidy of 3:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>id	flags	location	parents	metadata
0	0			
1	0			
id	flags	population	individual	time	metadata
0	1	0	0	0.00000000000000	
1	1	0	0	0.00000000000000	
2	1	0	0	0.00000000000000	
3	1	0	1	0.00000000000000	
4	1	0	1	0.00000000000000	
5	1	0	1	0.00000000000000	
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because we’re only interested in the initial conditions here we
set the <code class="docutils literal notranslate"><span class="pre">end_time</span></code> to zero: see the <a class="reference internal" href="#sec-ancestry-start-time"><span class="std std-ref">Setting the start time</span></a>
section for more details.</p>
</div>
<p>Our individual table has two rows (the number of <code class="docutils literal notranslate"><span class="pre">samples</span></code>)
and node table has 6 rows: three for each of the sampled
individuals.</p>
<p>Note that this is the <strong>default</strong>, and can be overridden by the
<a class="reference internal" href="api.html#msprime.SampleSet.ploidy" title="msprime.SampleSet.ploidy"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SampleSet.ploidy</span></code></a> value, as described in the
<a class="reference internal" href="#sec-ancestry-samples-sampling-details"><span class="std std-ref">Sample details</span></a> section.</p>
</div>
<div class="section" id="coalescent-time-scales">
<span id="sec-ancestry-ploidy-coalescent-time-scales"></span><h3>Coalescent time scales<a class="headerlink" href="#coalescent-time-scales" title="Permalink to this headline">¶</a></h3>
<p>The ploidy argument also
affects the time scale on which coalescence occurs,
since it affects the total number of genomes in the population
(see also <a class="reference internal" href="#sec-ancestry-demography"><span class="std std-ref">population size</span></a>).
For example, consider the following two simulations, which
are identical except for different <code class="docutils literal notranslate"><span class="pre">ploidy</span></code> values
(note we use the <a class="reference internal" href="api.html#msprime.SampleSet" title="msprime.SampleSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">SampleSet</span></code></a> object to make
sure we allocate the same number of <strong>nodes</strong>, as discussed
in the <a class="reference internal" href="#sec-ancestry-ploidy-default-num-nodes"><span class="std std-ref">Default number of nodes per sample individual</span></a> section):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="p">[</span><span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">ploidy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span>
<span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_23_0.svg" src="_images/ancestry_23_0.svg" /></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="p">[</span><span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span>
<span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_24_0.svg" src="_images/ancestry_24_0.svg" /></div>
</div>
<p>The resulting tree sequences are identical, except that node time differ by a
factor of 2, because in the underlying coalescent algorithm the total number of
genomes in the population acts as a time scaling.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Add a discussion here here about the Lambda coalescents an how
things are more complicated for them.</p>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The <a class="reference internal" href="#sec-ancestry-models-dtwf"><span class="std std-ref">Discrete Time Wright-Fisher</span></a> model is an explicitly diploid model
and it is therefore
an error to run it with any <code class="docutils literal notranslate"><span class="pre">ploidy</span></code> value other than 2.</p>
</div>
</div>
</div>
<div class="section" id="genome-properties">
<span id="sec-ancestry-genome-properties"></span><h2>Genome properties<a class="headerlink" href="#genome-properties" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sequence-length">
<span id="sec-ancestry-sequence-length"></span><h3>Sequence length<a class="headerlink" href="#sequence-length" title="Permalink to this headline">¶</a></h3>
<p>There are a number of different ways to specify the length of the
chromosome that we want to simulate. In the absence of recombination
and gene conversion, we assume a genome of length 1:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_26_0.svg" src="_images/ancestry_26_0.svg" /></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">sequence_length</span></code> parameter determines the length of the
simulated sequence:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_28_0.svg" src="_images/ancestry_28_0.svg" /></div>
</div>
<p>By default there is no recombination or gene conversion, and so we
therefore still have only one tree defining the ancestry of the
samples. The sequence length makes little difference if we are
considering only the ancestry of a non-recombining sequence, however,
this will be important if we are interested in adding
<a class="reference internal" href="mutations.html#sec-mutations"><span class="std std-ref">mutations</span></a> later.</p>
</div>
<div class="section" id="recombination">
<span id="sec-ancestry-recombination"></span><h3>Recombination<a class="headerlink" href="#recombination" title="Permalink to this headline">¶</a></h3>
<p>As we trace the ancestry of a sample of genomes backwards in time,
recombination has the effect of creating segments of genome
that have different (but highly correlated) genealogical trees.
The <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a> function has a <code class="docutils literal notranslate"><span class="pre">recombination_rate</span></code>
argument that allows us to flexibly specify both uniform and
non-uniform rates of recombination along the genome.</p>
<p>The simplest way to run simulations with recombination is to
use the <code class="docutils literal notranslate"><span class="pre">recombination_rate</span></code> and <code class="docutils literal notranslate"><span class="pre">sequence_length</span></code> parameters:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_30_0.svg" src="_images/ancestry_30_0.svg" /></div>
</div>
<p>Here, we we have four distinct trees along the genome,
created by recombination events.</p>
<p>We can also provide a <a class="reference internal" href="api.html#msprime.RateMap" title="msprime.RateMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">RateMap</span></code></a> argument to <code class="docutils literal notranslate"><span class="pre">recombination_rate</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rate_map</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">other_ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="n">rate_map</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">ts</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other_ts</span><span class="p">,</span> <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>There are two things to note here:</p>
<ol class="simple">
<li><p>We didn’t need to specify a <code class="docutils literal notranslate"><span class="pre">sequence_length</span></code> argument to
<a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a>, as this information is encapsulated by the <code class="docutils literal notranslate"><span class="pre">rate_map</span></code>
instance. (We can provide a value for <code class="docutils literal notranslate"><span class="pre">sequence_length</span></code> if we wish, but
it must be equal to the <a class="reference internal" href="api.html#msprime.RateMap.sequence_length" title="msprime.RateMap.sequence_length"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sequence_length</span></code></a> property of the
<a class="reference internal" href="api.html#msprime.RateMap" title="msprime.RateMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">RateMap</span></code></a>).</p></li>
<li><p>The result of the simulation for a <a class="reference internal" href="rate_maps.html#sec-rate-maps-creating-uniform"><span class="std std-ref">Uniform rate maps</span></a>
rate map with the same rate and <code class="docutils literal notranslate"><span class="pre">sequence_length</span></code> is identical to
the first simulation above.</p></li>
</ol>
<p>We can simulate non-uniform recombination by defining our <a class="reference internal" href="api.html#msprime.RateMap" title="msprime.RateMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">RateMap</span></code></a>
appropriately. For example, here we define a map in which the
rate over the first half of the sequence is one tenth of the second half:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rate_map</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">RateMap</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="n">rate</span><span class="o">=</span><span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="n">rate_map</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_36_0.svg" src="_images/ancestry_36_0.svg" /></div>
</div>
<p>Because the recombination rate in from position 10 to 20 is so much
higher than the rate from 0 to 10, we can see that all the recombinations
have fallen in the high recombination region.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p>See the <a class="reference internal" href="rate_maps.html#sec-rate-maps-creating"><span class="std std-ref">Creating rate maps</span></a> section for more examples of
creating <a class="reference internal" href="api.html#msprime.RateMap" title="msprime.RateMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">RateMap</span></code></a> instances.</p></li>
<li><p>See the <a class="reference internal" href="api.html#msprime.RateMap.read_hapmap" title="msprime.RateMap.read_hapmap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RateMap.read_hapmap()</span></code></a> method for reading in
genetic maps from text files.</p></li>
</ul>
</div>
</div>
<div class="section" id="gene-conversion">
<span id="sec-ancestry-gene-conversion"></span><h3>Gene conversion<a class="headerlink" href="#gene-conversion" title="Permalink to this headline">¶</a></h3>
<p>Gene conversion events are defined by two parameters: the rate at which gene
conversion events are initiated and the distribution of tract lengths.
In the default case of discrete genome coordinates, tract lengths are drawn
from a geometric distribution with mean <code class="docutils literal notranslate"><span class="pre">gene_conversion_tract_length</span></code> (which
must be at least 1). Note that if we specify a tract length of 1, then all
gene conversion tracts will have length exactly 1.
In the following example one gene conversion event of length 1 has occurred:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span> <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_38_0.svg" src="_images/ancestry_38_0.svg" /></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We can see the specific effect of gene conversion here in this simple
example, because the trees at either side of the event are identical.
However, this will not be true in general.</p>
</div>
<p>Continuous genomes can also be used. In this case the parameters define
the rate at which gene conversion events are initiated per unit of sequence
length and the mean of the exponentially distributed gene conversion tract
lengths. The following example shows the same simulation as above but for a
continuous genome:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span> <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">discrete_genome</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_42_0.svg" src="_images/ancestry_42_0.svg" /></div>
</div>
<p>Recombination and gene conversion at constant rates can be simulated alongside.
In the following example recombinations at site 60 and 97 have occurred in addition
to a gene conversion event covering the tract from site 76 to site 80.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span> <span class="n">sequence_length</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.003</span><span class="p">,</span>
    <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="mf">0.002</span><span class="p">,</span> <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_45_0.svg" src="_images/ancestry_45_0.svg" /></div>
</div>
<p>Variable recombination rates and constant gene conversion rates
can also be combined.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Variable rates of gene conversion breakpoint initiation are not currently
supported, but are planned for a future release. If you are interested
in this feature please let us know!</p>
</div>
</div>
<div class="section" id="discrete-or-continuous">
<span id="sec-ancestry-discrete-genome"></span><h3>Discrete or continuous?<a class="headerlink" href="#discrete-or-continuous" title="Permalink to this headline">¶</a></h3>
<p>By default, we assume that the genome we are simulating is <em>discrete</em>
so that genome coordinates are at integer positions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_48_0.svg" src="_images/ancestry_48_0.svg" /></div>
</div>
<p>We can also simulate a continous genome by setting
<code class="docutils literal notranslate"><span class="pre">discrete_genome=False</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">discrete_genome</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">33</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_51_0.svg" src="_images/ancestry_51_0.svg" /></div>
</div>
<p>Here we see that the breakpoints along the genome occur at floating point
positions. Simulating a continuous genome sequence can be useful for
theoretical work, but we recommend using discrete coordinates for most
purposes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With a discrete genome and a recombination rate of <span class="math notranslate nohighlight">\(r\)</span>,
the expected number of recombinations per unit time and per unit
length is <span class="math notranslate nohighlight">\(1-e^{-r}\)</span>. Therefore the total map length for a
segment of length <span class="math notranslate nohighlight">\(L\)</span> and recombination rate <span class="math notranslate nohighlight">\(r\)</span>
is <span class="math notranslate nohighlight">\(L (1 - e^{-r})\)</span>
and so <span class="math notranslate nohighlight">\(Lr (1 - r/2) &lt; L (1 - e^{-r}) &lt; Lr\)</span>.</p>
</div>
</div>
<div class="section" id="multiple-chromosomes">
<span id="sec-ancestry-multiple-chromosomes"></span><h3>Multiple chromosomes<a class="headerlink" href="#multiple-chromosomes" title="Permalink to this headline">¶</a></h3>
<p>Msprime does not directly support simulating multiple chromosomes
simultaneously, but we can emulate it using a single linear genome split into
chromosome segments. Multiple chromosomes are modelled by specifying
a recombination map with single base-pair segments with recombination
probability 1/2 separating adjacent chromosomes. The probability that
a recombination breakpoint occurs over one unit of time at a given base pair
that has recombination rate <span class="math notranslate nohighlight">\(r\)</span> is <span class="math notranslate nohighlight">\(1-e^{-r}\)</span>. Thus, we set the
recombination rate in the base pair segments separating chromosomes to
<span class="math notranslate nohighlight">\(\log(2)\)</span>. This ensures that the recombination probability each
generation is 1/2.</p>
<div class="section" id="do-i-need-to-do-this">
<h4>Do I need to do this?<a class="headerlink" href="#do-i-need-to-do-this" title="Permalink to this headline">¶</a></h4>
<p>The main purpose of simulating multiple chromosomes together (instead of
running independent simulations for each chromosome) is to capture
correlations between trees on distinct chromosomes. In many scenarios,
<strong>simulating multiple chromosomes may not be necessary</strong>, and independent
simulations may be preferable as they will be much more efficient.</p>
<p><a class="reference external" href="https://doi.org/10.1371/journal.pgen.1008619">Nelson et al. 2020</a> describes
a few cases where simulating multiple chromosomes using the DTWF is important
for accurately modeling shared patterns of variation between samples.
In large simulated cohorts, where many samples can be close
relatives, we need the DTWF model and multiple chromosomes to obtain the
correct distribution of the number and total length of shared IBD segments. We
similarly require multiple chromosomes and the DTWF model to get the correct
ancestry patterns for very recently admixed populations.</p>
<p>Additionally,
<a class="reference internal" href="#sec-ancestry-models-multiple-mergers"><span class="std std-ref">Multiple merger coalescents</span></a>
result in positively correlated ancestries between unlinked chromosomes
(see <a class="reference external" href="https://www.genetics.org/content/193/1/255">Birkner et al. 2013</a>).
This correlation does not break down in time and multiple chromosomes should
not be simulated independently under the multiple merger models. Unlinked
chromosomes should scatter into distinct ancestors instantaneously under
multiple merger coalescents, not with probability 1/2 per generation
as in discrete population models. In msprime, this waiting time of length zero
is approximated by an exponential distribution with rate <span class="math notranslate nohighlight">\(r\)</span>, i.e. the
recombination rate at the base pair separating the chromosomes, which
should be set to a high enough value to obtain an acceptable approximation.
We recommend considering in particular the relative error in comparison to
the magnitudes other waiting times which are likely to arise in the simulation.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Simulations of multiple chromosomes under either DTWF or the multiple merger
models should use a <a class="reference internal" href="#sec-ancestry-discrete-genome"><span class="std std-ref">discrete genome</span></a>.
While it is possible to set up such a simulation using a continuous genome,
we <em>strongly</em> recommend against it, as chromosome divisions cannot be defined
as discrete break points and the simulation will be very inefficient.</p>
</div>
</div>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>We first set up the chromosome coordinates, recombination rates, and the
corresponding recombination map. The following defines a recombination map for
three chromosomes each 1 cM in length:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="n">r_chrom</span> <span class="o">=</span> <span class="mf">1e-8</span>
<span class="n">r_break</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">chrom_positions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">,</span> <span class="mf">2e6</span><span class="p">,</span> <span class="mf">3e6</span><span class="p">]</span>
<span class="n">map_positions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">chrom_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">chrom_positions</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">chrom_positions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">chrom_positions</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="n">chrom_positions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">chrom_positions</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="p">]</span>
<span class="n">rates</span> <span class="o">=</span> <span class="p">[</span><span class="n">r_chrom</span><span class="p">,</span> <span class="n">r_break</span><span class="p">,</span> <span class="n">r_chrom</span><span class="p">,</span> <span class="n">r_break</span><span class="p">,</span> <span class="n">r_chrom</span><span class="p">]</span>
<span class="n">rate_map</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">RateMap</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">map_positions</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="n">rates</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We cannot use the default <a class="reference internal" href="api.html#msprime.StandardCoalescent" title="msprime.StandardCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardCoalescent</span></code></a> model to run simulations
of multiple chromosomes; doing so would be equivalent to running independent
replicate simulations and <strong>much</strong> less efficient. To get the correct
correlation between chromosomes, we must use a model like
<a class="reference internal" href="#sec-ancestry-models-dtwf"><span class="std std-ref">discrete-time Wright-Fisher</span></a>.
However, because correlations
between chromosomes break down very rapidly, we only need to simulate using
<code class="docutils literal notranslate"><span class="pre">dtwf</span></code> for roughly 10-20 generations, after which we can switch to the <code class="docutils literal notranslate"><span class="pre">hudson</span></code>
model to finish the simulation more efficiently (see the
<a class="reference internal" href="#sec-ancestry-models-specifying"><span class="std std-ref">Specifying ancestry models</span></a> section for more information on switching
between ancestry models).</p>
<p>In this example, we simulate 10 sampled diploid individuals using the
recombination map defined above for three chromosomes and switching from the
<code class="docutils literal notranslate"><span class="pre">dtwf</span></code> to <code class="docutils literal notranslate"><span class="pre">hudson</span></code> model 20 generations ago:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">10</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="n">rate_map</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">DiscreteTimeWrightFisher</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">StandardCoalescent</span><span class="p">(),</span>
    <span class="p">],</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">ts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<div>
  <style>
    .tskit-table thead tr th {text-align: left;padding: 0.5em 0.5em;}
    .tskit-table tbody tr td {padding: 0.5em 0.5em;}
    .tskit-table tbody tr td:first-of-type {text-align: left;}
    .tskit-details-label {vertical-align: top; padding-right:5px;}
    .tskit-table-set {display: inline-flex;flex-wrap: wrap;margin: -12px 0 0 -12px;width: calc(100% + 12px);}
    .tskit-table-set-table {margin: 12px 0 0 12px;}
    details {display: inline-block;}
    summary {cursor: pointer; outline: 0; display: list-item;}
  </style>
  <div class="tskit-table-set">
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="padding:0;line-height:21px;">
              <img style="height: 32px;display: inline-block;padding: 3px 5px 3px 0;"src="https://raw.githubusercontent.com/tskit-dev/administrative/main/tskit_logo.svg"/>
              <a target="_blank" href="https://tskit.readthedocs.io/en/latest/python-api.html#the-treesequence-class"> Tree Sequence
            </th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Trees</td><td>351</td></tr>
          <tr><td>Sequence Length</td><td>3000000.0</td></tr>
          <tr><td>Sample Nodes</td><td>20</td></tr>
          <tr><td>Total Size</td><td>53.8 KiB</td></tr>
          <tr>
            <td>Metadata</td><td style="text-align: left;">No Metadata</td></tr>
        </tbody>
      </table>
    </div>
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="line-height:21px;">Table</th>
            <th>Rows</th>
            <th>Size</th>
            <th>Has Metadata</th>
          </tr>
        </thead>
        <tbody>

      <tr>
        <td>Edges</td>
          <td>1254</td>
          <td>34.3 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Individuals</td>
          <td>10</td>
          <td>172 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Migrations</td>
          <td>0</td>
          <td>4 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Mutations</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Nodes</td>
          <td>342</td>
          <td>8.0 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Populations</td>
          <td>1</td>
          <td>216 Bytes</td>
          <td style="text-align: center;">
            ✅
          </td>
        </tr>

      <tr>
        <td>Provenances</td>
          <td>1</td>
          <td>1.3 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Sites</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>
</div>
</div></div>
</div>
<p>To place each chromosome in its own separate tree sequence, we can trim the full tree
sequence for each chromosome by defining the end points of each chromosome and
using the <a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.keep_intervals" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">keep_intervals()</span></code></a> method. It is important to
specify <code class="docutils literal notranslate"><span class="pre">simplify=False</span></code> so that node indices remain consistent across
chromosomes. The <a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.trim" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trim()</span></code></a> method is then used to trim
the tree sequences to the focal chromosome, so that position indices begin at
0 within each chromosome tree sequence.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts_chroms</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom_positions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">chrom_positions</span><span class="p">[</span><span class="n">j</span><span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">chrom_ts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">keep_intervals</span><span class="p">([[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">]],</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">trim</span><span class="p">()</span>
    <span class="n">ts_chroms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chrom_ts</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">chrom_ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>

<span class="c1"># the third chromosome</span>
<span class="n">chrom_ts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1000000.0
1000000.0
1000000.0
</pre></div>
</div>
<div class="output text_html">
<div>
  <style>
    .tskit-table thead tr th {text-align: left;padding: 0.5em 0.5em;}
    .tskit-table tbody tr td {padding: 0.5em 0.5em;}
    .tskit-table tbody tr td:first-of-type {text-align: left;}
    .tskit-details-label {vertical-align: top; padding-right:5px;}
    .tskit-table-set {display: inline-flex;flex-wrap: wrap;margin: -12px 0 0 -12px;width: calc(100% + 12px);}
    .tskit-table-set-table {margin: 12px 0 0 12px;}
    details {display: inline-block;}
    summary {cursor: pointer; outline: 0; display: list-item;}
  </style>
  <div class="tskit-table-set">
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="padding:0;line-height:21px;">
              <img style="height: 32px;display: inline-block;padding: 3px 5px 3px 0;"src="https://raw.githubusercontent.com/tskit-dev/administrative/main/tskit_logo.svg"/>
              <a target="_blank" href="https://tskit.readthedocs.io/en/latest/python-api.html#the-treesequence-class"> Tree Sequence
            </th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Trees</td><td>102</td></tr>
          <tr><td>Sequence Length</td><td>1000000.0</td></tr>
          <tr><td>Sample Nodes</td><td>20</td></tr>
          <tr><td>Total Size</td><td>23.7 KiB</td></tr>
          <tr>
            <td>Metadata</td><td style="text-align: left;">No Metadata</td></tr>
        </tbody>
      </table>
    </div>
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="line-height:21px;">Table</th>
            <th>Rows</th>
            <th>Size</th>
            <th>Has Metadata</th>
          </tr>
        </thead>
        <tbody>

      <tr>
        <td>Edges</td>
          <td>371</td>
          <td>10.1 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Individuals</td>
          <td>10</td>
          <td>172 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Migrations</td>
          <td>0</td>
          <td>4 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Mutations</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Nodes</td>
          <td>342</td>
          <td>8.0 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Populations</td>
          <td>1</td>
          <td>216 Bytes</td>
          <td style="text-align: center;">
            ✅
          </td>
        </tr>

      <tr>
        <td>Provenances</td>
          <td>3</td>
          <td>2.2 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Sites</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>
</div>
</div></div>
</div>
<p>This gives us a list of tree sequences, one for each chromosome, in the order
that they were stitched together in the initial recombination map.</p>
</div>
</div>
</div>
<div class="section" id="recording-more-information">
<h2>Recording more information<a class="headerlink" href="#recording-more-information" title="Permalink to this headline">¶</a></h2>
<p>By default <code class="docutils literal notranslate"><span class="pre">msprime</span></code> stores the minimum amount of information required
to represent the simulated genealogical history of the samples. Sometimes
we are interested in more detailed information; this section gives details
of options that allow us to do this.</p>
<div class="section" id="ancestral-recombination-graph">
<span id="sec-ancestry-full-arg"></span><h3>Ancestral recombination graph<a class="headerlink" href="#ancestral-recombination-graph" title="Permalink to this headline">¶</a></h3>
<p>In <code class="docutils literal notranslate"><span class="pre">msprime</span></code> we usually want to simulate the coalescent with recombination
and represent the output as efficiently as possible. As a result, we don’t
store individual recombination events, but rather their effects on the output
tree sequence. We also do not explicitly store common ancestor events that
do not result in marginal coalescences. For some purposes, however, we want
to get information on the full history of the simulation, not just the minimal
representation of its outcome. The <code class="docutils literal notranslate"><span class="pre">record_full_arg</span></code> option to
<a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a> provides this functionality, as illustrated in the
following example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>id	flags	population	individual	time	metadata
0	1	0	0	0.00000000000000	
1	1	0	0	0.00000000000000	
2	1	0	1	0.00000000000000	
3	1	0	1	0.00000000000000	
4	1	0	2	0.00000000000000	
5	1	0	2	0.00000000000000	
6	0	0	-1	0.21230673613116	
7	0	0	-1	0.51485156833449	
8	0	0	-1	0.71161448701612	
9	131072	0	-1	0.91107704517576	
10	131072	0	-1	0.91107704517576	
11	262144	0	-1	1.21743776274571	
12	0	0	-1	1.23130397112052	
13	0	0	-1	4.80416300493305	
</pre></div>
</div>
<img alt="_images/ancestry_60_1.svg" src="_images/ancestry_60_1.svg" /></div>
</div>
<p>After running the simulation we first print out the
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/data-model.html#node-table">node table</a>, which
contains information on all the nodes in the tree sequence. Note that <code class="docutils literal notranslate"><span class="pre">flags</span></code>
column contains several different values: all of the sample nodes (at time 0)
have a flag value of <code class="docutils literal notranslate"><span class="pre">1</span></code> (<a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.NODE_IS_SAMPLE" title="(in tskit v0.3)"><code class="xref py py-data docutils literal notranslate"><span class="pre">tskit.NODE_IS_SAMPLE</span></code></a>). Most other
nodes have a flag value of <code class="docutils literal notranslate"><span class="pre">0</span></code>, which is the standard for internal nodes
in a coalescent simulations.</p>
<p>Nodes 9 and 10 have flags equal to 131072 (<a class="reference internal" href="api.html#msprime.msprime.NODE_IS_RE_EVENT" title="msprime.msprime.NODE_IS_RE_EVENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">NODE_IS_RE_EVENT</span></code></a>), which
tells us that they correspond to a recombination event in the ARG. A
recombination event results in two extra nodes being recorded, one identifying
the individual providing the genetic material to the left of the breakpoint and
the other identifying the individuals providing the genetic material to the
right. The effect of this extra node can be seen in the trees: node 9 is
present as a ‘unary’ node in the left hand tree and node 10 in the right.</p>
<p>In this particular case, the first thing that happens to these two lineages
as we go up the tree sequence is that they coalesce straight back together again
at node 11, forming a (normally undetectable) “diamond event” in the ARG, and
explaining why the topology of both these trees appears the same. In a full ARG,
this is one of many ways that a coalescent event can occur without resulting in a
marginal coalescence, and which instead results in an additional unary node in the
trees. Such nodes are given a flags value of 262144 (<a class="reference internal" href="api.html#msprime.msprime.NODE_IS_CA_EVENT" title="msprime.msprime.NODE_IS_CA_EVENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">NODE_IS_CA_EVENT</span></code></a>).</p>
<p>If we wish to reduce these trees down to the minimal representation, we can
use <a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.simplify" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.simplify()</span></code></a>. The resulting tree sequence will have
all of these unary nodes removed and will be equivalent to (but not identical, due to
stochastic effects) calling <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a> without the <code class="docutils literal notranslate"><span class="pre">record_full_arg</span></code>
argument.</p>
<p>Migrations nodes are also recording in the ARG using the
<a class="reference internal" href="api.html#msprime.msprime.NODE_IS_MIG_EVENT" title="msprime.msprime.NODE_IS_MIG_EVENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">NODE_IS_MIG_EVENT</span></code></a> flag. See the <a class="reference internal" href="api.html#sec-api-node-flags"><span class="std std-ref">Node flags</span></a>
section for more details.</p>
</div>
<div class="section" id="migration-events">
<span id="sec-ancestry-record-migrations"></span><h3>Migration events<a class="headerlink" href="#migration-events" title="Permalink to this headline">¶</a></h3>
<p>When running simulations with <a class="reference internal" href="demography.html#sec-demography"><span class="std std-ref">demography</span></a>, by
default, migration events are not recorded in the resulting tree sequence.
While the population associated with each node is determined by the simulated migration
events, knowledge of the
precise sequence of migrations is useful in a number of situations: for example see
the <code class="docutils literal notranslate"><span class="pre">tskit</span></code>
<a class="reference external" href="https://tskit-dev.github.io/tutorials/introgression.html">tutorial on introgression.</a></p>
<p>The <code class="docutils literal notranslate"><span class="pre">record_migrations</span></code> parameter allows us to record these events in the
simulated tree sequence outputted by <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a>. Briefly, a migration record
encodes the node associated with the migration, the time of the event, the source and
destination populations (backwards in time), and the left and right coordinates of the
migrating segement. For more details on migration records, see the
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/data-model.html#sec-migration-table-definition" title="(in tskit v0.3)"><span class="xref std std-ref">migration table definition.</span></a></p>
<p>Here, we provide a simple example of the effect of setting <code class="docutils literal notranslate"><span class="pre">record_migrations=True</span></code>
using the <a class="reference internal" href="api.html#msprime.Demography.stepping_stone_model" title="msprime.Demography.stepping_stone_model"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stepping</span> <span class="pre">stone</span> <span class="pre">model</span></code></a>
where migration is permitted between adjacent populations. Additionally, we
set <code class="docutils literal notranslate"><span class="pre">record_full_arg=True</span></code> (see <a class="reference internal" href="#sec-ancestry-full-arg"><span class="std std-ref">previous section</span></a>)
to record nodes corresponding to migration events. This is not necessary, but will be
helpful to visualise the result.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">stepping_stone_model</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="n">migration_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">boundaries</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
    <span class="n">record_migrations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In the following visualisation, we trace the migration history of two samples backwards
in time to their most recent common ancestor. Each one of the ten populations in the
model is assigned a
colour and a position on the x axis. The time of migration events is recorded on the y
axis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tskit</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>

<span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">mig_color_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">linestyle</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">samples</span><span class="p">()[::</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;dotted&quot;</span><span class="p">,</span> <span class="s2">&quot;dashdot&quot;</span><span class="p">]):</span>
    <span class="n">mig</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">migrations</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">time</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span>
        <span class="n">migs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mig</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">u</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">cur_mig</span> <span class="ow">in</span> <span class="n">migs</span><span class="p">:</span>
            <span class="n">cur_mig</span> <span class="o">=</span> <span class="n">mig</span><span class="p">[</span><span class="n">cur_mig</span><span class="p">]</span>
            <span class="n">loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_mig</span><span class="o">.</span><span class="n">dest</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_mig</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">rgba</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">mig_color_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rgba</span><span class="p">)</span><span class="o">*</span><span class="mi">255</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="n">rgba</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Time of migration event&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Population&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_66_0.png" src="_images/ancestry_66_0.png" />
</div>
</div>
<p>Note also how many migration events occurred before the two
samples coalesced, even in this small example.</p>
<p>The next visualisation shows where each of these migrations fall on the edges
of the simulated tree. We show the nodes associated with each migration
event, colouring nodes and edges by the population with which they are associated
(using the same colour scheme as the previous visualisation).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mig_color_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;viridis&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">rgba</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">mig_color_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rgba</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>

<span class="n">edge_colors</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;.tree .edge {stroke-width:4px}&quot;</span>
<span class="n">pop</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">population</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span>
    <span class="n">edge_colors</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">mig_color_dict</span><span class="p">[</span><span class="n">pop</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span>
    <span class="n">string</span> <span class="o">+=</span> <span class="p">(</span>
        <span class="s2">&quot;.node.n&quot;</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;&gt; .sym {fill: rgb&quot;</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">mig_color_dict</span><span class="p">[</span><span class="n">pop</span><span class="p">[</span><span class="n">node</span><span class="p">]][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
        <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
    <span class="p">)</span>
    <span class="n">string</span> <span class="o">+=</span> <span class="p">(</span>
        <span class="s2">&quot;.node.n&quot;</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot; &gt; .edge {stroke: rgb&quot;</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">mig_color_dict</span><span class="p">[</span><span class="n">pop</span><span class="p">[</span><span class="n">node</span><span class="p">]][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
        <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
    <span class="p">)</span>
<span class="k">for</span> <span class="n">mig</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">migrations</span><span class="p">():</span>
    <span class="n">edge_colors</span><span class="p">[</span><span class="n">mig</span><span class="o">.</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">mig_color_dict</span><span class="p">[</span><span class="n">mig</span><span class="o">.</span><span class="n">source</span><span class="p">]</span>
    <span class="n">string</span> <span class="o">+=</span> <span class="p">(</span>
        <span class="s2">&quot;.node.n&quot;</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mig</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;&gt; .sym {fill: rgb&quot;</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">mig_color_dict</span><span class="p">[</span><span class="n">pop</span><span class="p">[</span><span class="n">mig</span><span class="o">.</span><span class="n">node</span><span class="p">]][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
        <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
    <span class="p">)</span>
    <span class="n">string</span> <span class="o">+=</span> <span class="p">(</span>
        <span class="s2">&quot;.node.n&quot;</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mig</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot; &gt; .edge {stroke: rgb&quot;</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">mig_color_dict</span><span class="p">[</span><span class="n">mig</span><span class="o">.</span><span class="n">dest</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]))</span>
        <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
    <span class="p">)</span>
<span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
<span class="n">SVG</span><span class="p">(</span>
    <span class="n">ts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span>
        <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">400</span><span class="p">),</span> <span class="n">style</span><span class="o">=</span><span class="n">string</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span> <span class="n">symbol_size</span><span class="o">=</span><span class="mi">10</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_68_0.svg" src="_images/ancestry_68_0.svg" /></div>
</div>
</div>
<div class="section" id="census-events">
<span id="sec-ancestry-census-events"></span><h3>Census events<a class="headerlink" href="#census-events" title="Permalink to this headline">¶</a></h3>
<p>Census events allow you to add a node to each branch of the tree sequence at a given time
during the simulation. This can be useful when you wish to study haplotypes that are
ancestral to your simulated sample, or when you wish to know which lineages were present in
which populations at specified times.</p>
<p>For instance, the following example creates a two population island
model <a class="reference internal" href="api.html#msprime.Demography" title="msprime.Demography"><code class="xref py py-class docutils literal notranslate"><span class="pre">Demography</span></code></a>, with the populations exchanging migrants
at rate 0.05. At generation 5000, we add a census event using the
<a class="reference internal" href="api.html#msprime.Demography.add_census" title="msprime.Demography.add_census"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Demography.add_census()</span></code></a> method
to determine where each of the lineages is at that time:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">island_model</span><span class="p">([</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">],</span> <span class="n">migration_rate</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_census</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">141</span>
<span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_70_0.svg" src="_images/ancestry_70_0.svg" /></div>
</div>
<p>The resulting tree sequence has nodes on each tree at the specified census time.
These are the nodes with IDs 8, 9, 10, 11, 12 and 13.</p>
<p>This tells us that the genetic material ancestral to the present day sample was
held within 5 haplotypes at time 5000. The node table shows us that four of
these haplotypes (nodes 8, 9, 10 and 11) were in population 0 at this time, and
two of these haplotypes (nodes 12 and 13) were in population 1 at this time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>id	flags	population	individual	time	metadata
0	1	0	0	0.00000000000000	
1	1	0	0	0.00000000000000	
2	1	1	1	0.00000000000000	
3	1	1	1	0.00000000000000	
4	0	1	-1	2331.91109773698145	
5	0	1	-1	3741.02811877494014	
6	0	0	-1	4216.80416679880909	
7	0	1	-1	4580.66488182548528	
8	1048576	0	-1	5000.00000000000000	
9	1048576	0	-1	5000.00000000000000	
10	1048576	0	-1	5000.00000000000000	
11	1048576	0	-1	5000.00000000000000	
12	1048576	1	-1	5000.00000000000000	
13	1048576	1	-1	5000.00000000000000	
14	0	1	-1	5232.65267391737507	
15	0	0	-1	8192.48105713510449	
</pre></div>
</div>
</div>
</div>
<p>If we wish to study these ancestral haplotypes further, we can simplify the tree sequence
with respect to the census nodes and perform subsequent analyses on this simplified tree
sequence.
In this example, <code class="docutils literal notranslate"><span class="pre">ts_anc</span></code> is a tree sequence obtained from the original tree sequence
<code class="docutils literal notranslate"><span class="pre">ts</span></code> by labelling the census nodes as samples and removing all nodes and edges that are
not ancestral to these census nodes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">flags</span><span class="o">==</span><span class="n">msprime</span><span class="o">.</span><span class="n">NODE_IS_CEN_EVENT</span><span class="p">]</span>
<span class="n">ts_anc</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="using-the-dtwf-model">
<span id="sec-ancestry-census-events-dtwf"></span><h4>Using the DTWF model<a class="headerlink" href="#using-the-dtwf-model" title="Permalink to this headline">¶</a></h4>
<p>Census events assume that they are being used as part of a continuous time
simulation process, in which multiple events are guaranteed not to happen
at the same time. However, the <a class="reference internal" href="api.html#msprime.DiscreteTimeWrightFisher" title="msprime.DiscreteTimeWrightFisher"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeWrightFisher</span></code></a> model does
not meet these assumptions, and allows multiple events (such as coalescences,
migrations etc) to all occur at the same time. This includes census events,
which can lead to errors when used in conjunction with the DTWF model.</p>
<p>Consider the following example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="p">()</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_76_0.svg" src="_images/ancestry_76_0.svg" /></div>
</div>
<p>We can see that a coalescence happens at time 21, giving node 9. Now, let’s
try to perform a census at time 21:</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="p">()</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_census</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">LibraryError</span><span class="g g-Whitespace">                              </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">43</span><span class="o">-</span><span class="mi">8564</span><span class="n">f026503b</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="n">demography</span><span class="o">.</span><span class="n">add_census</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="ne">----&gt; </span><span class="mi">4</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">sim_ancestry</span><span class="nt">(samples, demography, sequence_length, discrete_genome, recombination_rate, gene_conversion_rate, gene_conversion_tract_length, population_size, ploidy, model, initial_state, start_time, end_time, record_migrations, record_full_arg, num_labels, random_seed, num_replicates, replicate_index, record_provenance)</span>
<span class="g g-Whitespace">   </span><span class="mi">1164</span>         <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1165</span>     <span class="p">)</span>
<span class="ne">-&gt; </span><span class="mi">1166</span>     <span class="k">return</span> <span class="n">_wrap_replicates</span><span class="p">(</span>
<span class="g g-Whitespace">   </span><span class="mi">1167</span>         <span class="n">sim</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1168</span>         <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">,</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">_wrap_replicates</span><span class="nt">(simulator, num_replicates, replicate_index, provenance_dict, mutation_rate)</span>
<span class="g g-Whitespace">    </span><span class="mi">671</span>     <span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">672</span>     <span class="k">if</span> <span class="n">replicate_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">673</span>         <span class="n">deque</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">674</span>         <span class="k">return</span> <span class="n">deque</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="g g-Whitespace">    </span><span class="mi">675</span>     <span class="k">else</span><span class="p">:</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">run_replicates</span><span class="nt">(self, num_replicates, mutation_rate, provenance_dict)</span>
<span class="g g-Whitespace">   </span><span class="mi">1435</span>         <span class="k">for</span> <span class="n">replicate_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_replicates</span><span class="p">):</span>
<span class="g g-Whitespace">   </span><span class="mi">1436</span>             <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting replicate </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">replicate_index</span><span class="p">)</span>
<span class="ne">-&gt; </span><span class="mi">1437</span>             <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="g g-Whitespace">   </span><span class="mi">1438</span>             <span class="k">if</span> <span class="n">mutation_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="g g-Whitespace">   </span><span class="mi">1439</span>                 <span class="c1"># This is only called from simulate() or the ms interface,</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">run</span><span class="nt">(self, event_chunk, debug_func)</span>
<span class="g g-Whitespace">   </span><span class="mi">1400</span>                 <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Model durations must be &gt;= 0&quot;</span><span class="p">)</span>
<span class="g g-Whitespace">   </span><span class="mi">1401</span>             <span class="n">end_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="n">model_duration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>
<span class="ne">-&gt; </span><span class="mi">1402</span>             <span class="n">exit_reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_until</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="p">,</span> <span class="n">debug_func</span><span class="p">)</span>
<span class="g g-Whitespace">   </span><span class="mi">1403</span>             <span class="k">if</span> <span class="n">exit_reason</span> <span class="o">==</span> <span class="n">ExitReason</span><span class="o">.</span><span class="n">COALESCENCE</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span>
<span class="g g-Whitespace">   </span><span class="mi">1404</span>                 <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping remaining </span><span class="si">%d</span><span class="s2"> models&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">_run_until</span><span class="nt">(self, end_time, event_chunk, debug_func)</span>
<span class="g g-Whitespace">   </span><span class="mi">1365</span>         <span class="n">ret</span> <span class="o">=</span> <span class="n">ExitReason</span><span class="o">.</span><span class="n">MAX_EVENTS</span>
<span class="g g-Whitespace">   </span><span class="mi">1366</span>         <span class="k">while</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">ExitReason</span><span class="o">.</span><span class="n">MAX_EVENTS</span><span class="p">:</span>
<span class="ne">-&gt; </span><span class="mi">1367</span>             <span class="n">ret</span> <span class="o">=</span> <span class="n">ExitReason</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="p">))</span>
<span class="g g-Whitespace">   </span><span class="mi">1368</span>             <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">end_time</span><span class="p">:</span>
<span class="g g-Whitespace">   </span><span class="mi">1369</span>                 <span class="c1"># Currently the Pedigree and Sweeps models are &quot;non-rentrant&quot;</span>

<span class="ne">LibraryError</span>: The simulation model supplied resulted in a parent node having a time value &lt;= to its child. This can occur either as a result of multiple bottlenecks happening at the same time or because of numerical imprecision with very small population sizes.
</pre></div>
</div>
</div>
</div>
<p>We got an error from msprime about a parent node having a time value &lt;= to its child,
which occured because we tried to add set of census nodes at time 21, but node 9 was
already at time 21, giving a zero branch length (which is disallowed by tskit).</p>
<p>The solution is to use non-integer time values when performing a census
under the DTWF:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="p">()</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_census</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mf">21.5</span><span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_80_0.svg" src="_images/ancestry_80_0.svg" /></div>
</div>
</div>
</div>
</div>
<div class="section" id="manipulating-simulation-time">
<h2>Manipulating simulation time<a class="headerlink" href="#manipulating-simulation-time" title="Permalink to this headline">¶</a></h2>
<div class="section" id="stopping-simulations-early">
<span id="sec-ancestry-end-time"></span><h3>Stopping simulations early<a class="headerlink" href="#stopping-simulations-early" title="Permalink to this headline">¶</a></h3>
<p>In most simulations we want to simulate a complete history for our samples:
that is, to when we have a common ancestor at every point along the
sequence. For example, here we generate a complete ancestral history
for two diploid samples:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_82_0.svg" src="_images/ancestry_82_0.svg" /></div>
</div>
<p>Sometimes we would like to stop the simulation early, <strong>before</strong> complete
coalescence has occured; perhaps we would like to
<a class="reference internal" href="#sec-ancestry-initial-state-combining"><span class="std std-ref">combine several simulations</span></a>
with different properties, or we are really only interested in the
recent past and simulating more ancient processes would be a waste
of computational resources.</p>
<p>We can do this by specifying a <code class="docutils literal notranslate"><span class="pre">end_time</span></code> value.
Let’s repeat the same simulation as above with an <code class="docutils literal notranslate"><span class="pre">end_time</span></code> of 2:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_84_0.svg" src="_images/ancestry_84_0.svg" /></div>
</div>
<p>There are a number of important things to observe about this
tree sequence:</p>
<ol class="simple">
<li><p>The history up until time 2 is <strong>identical</strong> to the original simulation.</p></li>
<li><p>The first tree has not fully coalesced, and we therefore have <strong>multiple
roots</strong>. Trees with multiple roots are fully supported in tskit.</p></li>
<li><p>The nodes 8 and 9 are at time 2 (our <code class="docutils literal notranslate"><span class="pre">end_time</span></code> value), and these
connect to the uncoalesced portions of the tree. These “unary” nodes
are very important for ensuring the correct statistical properties
when we
<a class="reference internal" href="#sec-ancestry-initial-state-combining"><span class="std std-ref">combine multiple simulations</span></a>.</p></li>
</ol>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The ancestry model <a class="reference internal" href="#sec-ancestry-models-specifying-duration"><span class="std std-ref">duration</span></a>
can also be used to stop simulations before coalescence.</p>
</div>
<p>For discrete time models, the exact interpretation
of the <code class="docutils literal notranslate"><span class="pre">end_time</span></code> is important — we continue to simulate
the process while the time is &lt;= <code class="docutils literal notranslate"><span class="pre">end_time</span></code>. For example here
we use an <code class="docutils literal notranslate"><span class="pre">end_time</span></code> of 1 generation in a <a class="reference internal" href="#sec-ancestry-models-dtwf"><span class="std std-ref">Discrete Time Wright-Fisher</span></a>
simulation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_86_0.svg" src="_images/ancestry_86_0.svg" /></div>
</div>
<p>We have run 1 generation of the DTWF, resulting in the coalescence
at node 9.</p>
</div>
<div class="section" id="setting-the-start-time">
<span id="sec-ancestry-start-time"></span><h3>Setting the start time<a class="headerlink" href="#setting-the-start-time" title="Permalink to this headline">¶</a></h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Setting simulation start time is an advanced feature which is rarely
needed in practice.</p>
</div>
<p>Sometimes we need control when the simulation process starts. For
example, given the initial configuration of at time zero we want to
“jump ahead” to a later time point before we start generating
random events. Consider the following example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
            <div>
                <style scoped="">
                    .tskit-table tbody tr th:only-of-type {vertical-align: middle;}
                    .tskit-table tbody tr th {vertical-align: top;}
                    .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
                    .tskit-table tbody th {padding: 0.5em 0.5em;}
                </style>
                <table border="1" class="tskit-table">
                    <thead>
                        <tr>
                            <th>id</th><th>flags</th><th>population</th><th>individual</th><th>time</th><th>metadata</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0.00000000000000</td><td></td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0.00000000000000</td><td></td></tr>
<tr><td>2</td><td>1</td><td>0</td><td>1</td><td>0.00000000000000</td><td></td></tr>
<tr><td>3</td><td>1</td><td>0</td><td>1</td><td>0.00000000000000</td><td></td></tr>
<tr><td>4</td><td>0</td><td>0</td><td>-1</td><td>0.15642269424061</td><td></td></tr>
<tr><td>5</td><td>0</td><td>0</td><td>-1</td><td>0.29152169532801</td><td></td></tr>
<tr><td>6</td><td>0</td><td>0</td><td>-1</td><td>2.11740681320717</td><td></td></tr>

                    </tbody>
                </table>
            </div>
</div></div>
</div>
<p>Now we run the same simulation with a <code class="docutils literal notranslate"><span class="pre">start_time</span></code> of 10:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
            <div>
                <style scoped="">
                    .tskit-table tbody tr th:only-of-type {vertical-align: middle;}
                    .tskit-table tbody tr th {vertical-align: top;}
                    .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
                    .tskit-table tbody th {padding: 0.5em 0.5em;}
                </style>
                <table border="1" class="tskit-table">
                    <thead>
                        <tr>
                            <th>id</th><th>flags</th><th>population</th><th>individual</th><th>time</th><th>metadata</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0.00000000000000</td><td></td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0.00000000000000</td><td></td></tr>
<tr><td>2</td><td>1</td><td>0</td><td>1</td><td>0.00000000000000</td><td></td></tr>
<tr><td>3</td><td>1</td><td>0</td><td>1</td><td>0.00000000000000</td><td></td></tr>
<tr><td>4</td><td>0</td><td>0</td><td>-1</td><td>10.15642269424061</td><td></td></tr>
<tr><td>5</td><td>0</td><td>0</td><td>-1</td><td>10.29152169532801</td><td></td></tr>
<tr><td>6</td><td>0</td><td>0</td><td>-1</td><td>12.11740681320717</td><td></td></tr>

                    </tbody>
                </table>
            </div>
</div></div>
</div>
<p>We can see that the results are identical except that 10 has
been added to all of the internal node times.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>It is important to note that the <code class="docutils literal notranslate"><span class="pre">start_time</span></code> only controls the
“random” events that happen within the simulation model: events
that are specified to occur at a given time (such as sampling
or demographic events) will occur at that time, even if this
is before the <code class="docutils literal notranslate"><span class="pre">start_time</span></code>.</p>
</div>
<p>Consider the following example in which we create a simple
<a class="reference internal" href="demography.html#sec-demography-examples-population-tree"><span class="std std-ref">population tree</span></a>
demography, and then take samples at different times all <em>before</em>
<code class="docutils literal notranslate"><span class="pre">start_time</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="p">()</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population_split</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">derived</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">],</span> <span class="n">ancestral</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SampleSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">6</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
    <span class="n">ploidy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">ts</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
            <div>
                <style scoped="">
                    .tskit-table tbody tr th:only-of-type {vertical-align: middle;}
                    .tskit-table tbody tr th {vertical-align: top;}
                    .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
                    .tskit-table tbody th {padding: 0.5em 0.5em;}
                </style>
                <table border="1" class="tskit-table">
                    <thead>
                        <tr>
                            <th>id</th><th>flags</th><th>population</th><th>individual</th><th>time</th><th>metadata</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1.00000000000000</td><td></td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>2.00000000000000</td><td></td></tr>
<tr><td>2</td><td>1</td><td>2</td><td>2</td><td>6.00000000000000</td><td></td></tr>
<tr><td>3</td><td>0</td><td>2</td><td>-1</td><td>52.47084127199754</td><td></td></tr>
<tr><td>4</td><td>0</td><td>2</td><td>-1</td><td>66.18169933131182</td><td></td></tr>

                    </tbody>
                </table>
            </div>
</div></div>
</div>
<p>We can see that the samples we specify are in the correct populations
and their node times are at the sampling time. Note that all the
coalescences happen in population ID 2 (“C”), indicating that the
lineages from “A” and “B” moved there at the time of the split
(which we can observe directly using the
<a class="reference internal" href="#sec-ancestry-record-migrations"><span class="std std-ref">record_migrations</span></a> option if we wish).
Note also that we drew a sample from population “C” at time 6,
which is <a class="reference internal" href="demography.html#sec-demography-direction-of-time"><span class="std std-ref">after</span></a> the split;
if we tried to draw a sample before the split, we would get an
error because the population would be
<a class="reference internal" href="demography.html#sec-demography-populations-life-cycle"><span class="std std-ref">inactive</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the <a class="reference internal" href="#sec-ancestry-event-order"><span class="std std-ref">Order of event execution</span></a> section for details
of the precise order in which fixed-time events occur.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same considerations apply when we are running simulations based
on a given <a class="reference internal" href="#sec-ancestry-initial-state"><span class="std std-ref">initial state</span></a>; in
this case, the <code class="docutils literal notranslate"><span class="pre">start_time</span></code> is by default set to the time
of the youngest root in the input trees.</p>
</div>
</div>
<div class="section" id="order-of-event-execution">
<span id="sec-ancestry-event-order"></span><h3>Order of event execution<a class="headerlink" href="#order-of-event-execution" title="Permalink to this headline">¶</a></h3>
<p>There are two different classes of event that happen in ancestry
simulations: “fixed” and “random” events. Random events are
generated by the ancestry model, and fixed events are those
that occur at a time specified by the user. Fixed events
are <a class="reference internal" href="demography.html#sec-demography-events"><span class="std std-ref">demographic events</span></a> or
<a class="reference internal" href="#sec-ancestry-samples"><span class="std std-ref">sampling events</span></a>.
If a number of different
events are specified to occur at exactly the same time, then:</p>
<ol class="simple">
<li><p>All demographic events at this time are run, <em>in the order they
were specified</em>.</p></li>
<li><p>Sampling events occur immediately after all the demographic events
have been executed. (See the <a class="reference internal" href="#sec-ancestry-samples-sampling-time"><span class="std std-ref">Sampling time</span></a>
section for more details on ancient sampling events.)</p></li>
</ol>
<p>These details are slightly different for the <a class="reference internal" href="#sec-ancestry-models-dtwf"><span class="std std-ref">Discrete Time Wright-Fisher</span></a>
model. See the <a class="reference internal" href="api.html#msprime.DiscreteTimeWrightFisher" title="msprime.DiscreteTimeWrightFisher"><code class="xref py py-class docutils literal notranslate"><span class="pre">API</span> <span class="pre">documentation</span></code></a> for
details.</p>
</div>
</div>
<div class="section" id="specifying-the-initial-state">
<span id="sec-ancestry-initial-state"></span><h2>Specifying the initial state<a class="headerlink" href="#specifying-the-initial-state" title="Permalink to this headline">¶</a></h2>
<p>By default <code class="docutils literal notranslate"><span class="pre">msprime</span></code> simulations are initialised by specifying a set of
<a class="reference internal" href="#sec-ancestry-samples"><span class="std std-ref">samples</span></a>,
which sets up the simulation with segments of ancestral material covering the
whole sequence. Internally, this initial state is implemented by
setting up a <a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TableCollection" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TableCollection</span></code></a> which contains the
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/data-model.html#sec-population-table-definition" title="(in tskit v0.3)"><span class="xref std std-ref">population</span></a>,
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/data-model.html#sec-node-table-definition" title="(in tskit v0.3)"><span class="xref std std-ref">node</span></a>,
and <a class="reference external" href="https://tskit.dev/tskit/docs/stable/data-model.html#sec-individual-table-definition" title="(in tskit v0.3)"><span class="xref std std-ref">individual</span></a> information.
The low-level simulation code then reads these tables and sets up the
simulation accordingly. We can see what this initial state looks like
by setting up a simple simulation and stopping it immediately:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">initial_ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">initial_ts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<div>
  <style>
    .tskit-table thead tr th {text-align: left;padding: 0.5em 0.5em;}
    .tskit-table tbody tr td {padding: 0.5em 0.5em;}
    .tskit-table tbody tr td:first-of-type {text-align: left;}
    .tskit-details-label {vertical-align: top; padding-right:5px;}
    .tskit-table-set {display: inline-flex;flex-wrap: wrap;margin: -12px 0 0 -12px;width: calc(100% + 12px);}
    .tskit-table-set-table {margin: 12px 0 0 12px;}
    details {display: inline-block;}
    summary {cursor: pointer; outline: 0; display: list-item;}
  </style>
  <div class="tskit-table-set">
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="padding:0;line-height:21px;">
              <img style="height: 32px;display: inline-block;padding: 3px 5px 3px 0;"src="https://raw.githubusercontent.com/tskit-dev/administrative/main/tskit_logo.svg"/>
              <a target="_blank" href="https://tskit.readthedocs.io/en/latest/python-api.html#the-treesequence-class"> Tree Sequence
            </th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Trees</td><td>1</td></tr>
          <tr><td>Sequence Length</td><td>1.0</td></tr>
          <tr><td>Sample Nodes</td><td>2</td></tr>
          <tr><td>Total Size</td><td>1.3 KiB</td></tr>
          <tr>
            <td>Metadata</td><td style="text-align: left;">No Metadata</td></tr>
        </tbody>
      </table>
    </div>
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="line-height:21px;">Table</th>
            <th>Rows</th>
            <th>Size</th>
            <th>Has Metadata</th>
          </tr>
        </thead>
        <tbody>

      <tr>
        <td>Edges</td>
          <td>0</td>
          <td>4 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Individuals</td>
          <td>1</td>
          <td>28 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Migrations</td>
          <td>0</td>
          <td>4 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Mutations</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Nodes</td>
          <td>2</td>
          <td>52 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Populations</td>
          <td>1</td>
          <td>216 Bytes</td>
          <td style="text-align: center;">
            ✅
          </td>
        </tr>

      <tr>
        <td>Provenances</td>
          <td>1</td>
          <td>953 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Sites</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>
</div>
</div></div>
</div>
<p>We can see that the returned tree sequence has one population,
two sample nodes and one individual (since sample individuals are
<a class="reference internal" href="#sec-ancestry-ploidy"><span class="std std-ref">diploid</span></a> by default). There are no
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/data-model.html#sec-edge-table-definition" title="(in tskit v0.3)"><span class="xref std std-ref">edges</span></a> because the simulation
didn’t run for any period of time: we’re essentially just returning
the initial state used to start the simulation.</p>
<p>Then, running a simulation in which the <code class="docutils literal notranslate"><span class="pre">initial_state</span></code> is equal to
<code class="docutils literal notranslate"><span class="pre">initial_ts</span></code> is <em>precisely</em> the same as running the simulation
with the same arguments as we used above:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts1</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="n">initial_state</span><span class="o">=</span><span class="n">initial_ts</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ts2</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">ts1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">ts2</span><span class="p">,</span> <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">initial_state</span></code> tree sequence only contains the
information about the ancestral histories, and not any of the
simulation parameters. In the previous example we used default
parameters to keep things simple, but in general the full
simulation model will need to be specified as well as the initial state.
In particular, see the <a class="reference internal" href="#sec-ancestry-initial-state-demography"><span class="std std-ref">Interaction with demography</span></a> section.</p>
</div>
<p>While it is possible to specify the initial state manually by
constructing the input tree sequence,
it is an advanced topic and rarely necessary. More often we are
interested in specifying the initial state of an <code class="docutils literal notranslate"><span class="pre">msprime</span></code>
simulation using the output of <em>another</em> simulation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">initial_state</span></code> tree sequence is quite literally the initial
state of the tree sequence that is returned at the end of a simulation,
and that any information present (including metadata) will not be
altered.</p>
</div>
<div class="section" id="combining-backward-time-simulations">
<span id="sec-ancestry-initial-state-combining"></span><h3>Combining backward-time simulations<a class="headerlink" href="#combining-backward-time-simulations" title="Permalink to this headline">¶</a></h3>
<p>Suppose that we wished to simulate a scenario
in which we have recombination happening at some rate in the recent past,
and in the more distant past there is no recombination.
We can do this by combining the simulations,
using one as the <code class="docutils literal notranslate"><span class="pre">initial_state</span></code> for the other.</p>
<p>We first run the simulation of the recent past:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts1</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span> <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts1</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_98_0.svg" src="_images/ancestry_98_0.svg" /></div>
</div>
<p>Some recombination and coalescence has happened and we have three
marginal trees along the genome. None of these trees has fully coalesced,
and so each of the trees has multiple roots.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The set of nodes at time 10 connecting to all the internal nodes in the
trees are very important: without these nodes and unary edges, the
statistical properties of the combined simulations would not be correct!
(See also section below on
<a class="reference internal" href="#sec-ancestry-initial-state-forward-simulations"><span class="std std-ref">forward simulations</span></a>.)</p>
</div>
<p>We then run the next phase of the simulation in which there is
<em>no</em> recombination by passing <code class="docutils literal notranslate"><span class="pre">ts1</span></code> as the argument to <code class="docutils literal notranslate"><span class="pre">initial_state</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts2</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="n">initial_state</span><span class="o">=</span><span class="n">ts1</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts2</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_100_0.svg" src="_images/ancestry_100_0.svg" /></div>
</div>
<p>Since there is no recombination in this more ancient simulation,
node <code class="docutils literal notranslate"><span class="pre">12</span></code> is the MRCA in all three trees. The unary nodes
<code class="docutils literal notranslate"><span class="pre">6</span></code>, <code class="docutils literal notranslate"><span class="pre">7</span></code>, <code class="docutils literal notranslate"><span class="pre">8</span></code>, and <code class="docutils literal notranslate"><span class="pre">9</span></code> marking the transition between the
two simulation regimes are still present in the trees. If you
wish to remove these, we can use the <a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.simplify" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tskit.TreeSequence.simplify()</span></code></a>
method:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts_simplified</span> <span class="o">=</span> <span class="n">ts2</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts_simplified</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_102_0.svg" src="_images/ancestry_102_0.svg" /></div>
</div>
</div>
<div class="section" id="interaction-with-demography">
<span id="sec-ancestry-initial-state-demography"></span><h3>Interaction with demography<a class="headerlink" href="#interaction-with-demography" title="Permalink to this headline">¶</a></h3>
<p>In the previous example we saw how to combine two single population simulations.
We can also combine more complex simulations involving
<a class="reference internal" href="demography.html#sec-demography"><span class="std std-ref">demography</span></a>, but care needs to be taken to ensure that
the correct models are simulated in each part of the simulation.
Suppose we have simple model with a
<a class="reference internal" href="demography.html#sec-demography-events-population-split"><span class="std std-ref">population split</span></a>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="p">()</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Contemporary population A&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Contemporary population B&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Ancestral population&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population_split</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">ancestral</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">derived</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">])</span>
<span class="n">demography</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div style="margin-left:20px"><div><style scoped="">
            .tskit-table thead tr th:only-of-type {vertical-align: middle;}
            .tskit-table thead tr th {text-align: center;vertical-align: top;}
            .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
            .tskit-table tbody th {padding: 0.5em 0.5em;}
        </style><b>Populations (3)</b><table border="1" class="tskit-table"><thead><tr><th>id</th><th>name</th><th>description</th><th>initial_size</th><th>growth_rate</th><th>default_sampling_time</th><th>extra_metadata</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>Contemporary population A</td><td>100.0</td><td>0</td><td>0</td><td>{}</td></tr><tr><td>1</td><td>B</td><td>Contemporary population B</td><td>200.0</td><td>0</td><td>0</td><td>{}</td></tr><tr><td>2</td><td>C</td><td>Ancestral population</td><td>300.0</td><td>0</td><td>1e+02</td><td>{}</td></tr></tbody></table></div><div><style scoped="">
            .tskit-table thead tr th:only-of-type {vertical-align: middle;}
            .tskit-table thead tr th {text-align: center;vertical-align: top;}
            .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
            .tskit-table tbody th {padding: 0.5em 0.5em;}
        </style><b>Migration matrix (all zero)</b><table border="1" class="tskit-table"><thead><tr></tr></thead><tbody></tbody></table></div><div><style scoped="">
            .tskit-table thead tr th:only-of-type {vertical-align: middle;}
            .tskit-table thead tr th {text-align: center;vertical-align: top;}
            .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
            .tskit-table tbody th {padding: 0.5em 0.5em;}
        </style><b>Events (1)</b><table border="1" class="tskit-table"><thead><tr><th>time</th><th>type</th><th>parameters</th><th>effect</th></tr></thead><tbody><tr><td>100</td><td><a href='https://tskit.dev/msprime/docs/latest/api.html#msprime.Demography.add_population_split'>Population Split</a></td><td>derived=[A, B], ancestral=C</td><td>Moves all lineages from derived populations &#x27;A&#x27; and &#x27;B&#x27; to the ancestral &#x27;C&#x27; population. Also set the derived populations to inactive, and all migration rates to and from the derived populations to zero.</td></tr></tbody></table></div></div></div></div>
</div>
<p>Then, we run a simulation of this model for 50 generations:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts1</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">ts1</span><span class="o">.</span><span class="n">population</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">population</span><span class="p">)</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ts1</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts1</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_106_0.svg" src="_images/ancestry_106_0.svg" /></div>
</div>
<p>After 50 generations we can see there has been a coalescence in population <code class="docutils literal notranslate"><span class="pre">A</span></code>
but none in <code class="docutils literal notranslate"><span class="pre">B</span></code> and we therefore have three lineages left when the simulation
finishes. We can then continue the simulation based on this initial state:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts2</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">initial_state</span><span class="o">=</span><span class="n">ts1</span><span class="p">,</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">5678</span><span class="p">)</span>
<span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">ts2</span><span class="o">.</span><span class="n">population</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">population</span><span class="p">)</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ts2</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts2</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_108_0.svg" src="_images/ancestry_108_0.svg" /></div>
</div>
<p>Note that we use the <strong>same</strong> demography object, and so the lineages
migrate and ultimately coalesce in population <code class="docutils literal notranslate"><span class="pre">C</span></code>, as we’d expect.
This is the simplest case, in which we already have the demography
object which we can use to model the entire simulation from end-to-end.</p>
<p>In other cases (e.g. when working with simulations from a different
program), we don’t have the <a class="reference internal" href="api.html#msprime.Demography" title="msprime.Demography"><code class="xref py py-class docutils literal notranslate"><span class="pre">Demography</span></code></a> object at hand
and we need to create one that is both compatible with the
<code class="docutils literal notranslate"><span class="pre">initial_state</span></code> tree sequence and reflects the demographic
model that we are interested in using. The best way to do this
is to use the <a class="reference internal" href="api.html#msprime.Demography.from_tree_sequence" title="msprime.Demography.from_tree_sequence"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Demography.from_tree_sequence()</span></code></a> method to
first get a base demography that is based on the
tree sequence <a class="reference external" href="https://tskit.dev/tskit/docs/stable/data-model.html#sec-population-table-definition" title="(in tskit v0.3)"><span class="xref std std-ref">population table</span></a>
and <a class="reference external" href="https://tskit.dev/tskit/docs/stable/metadata.html#sec-metadata" title="(in tskit v0.3)"><span class="xref std std-ref">metadata</span></a>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">from_tree_sequence</span><span class="p">(</span><span class="n">ts1</span><span class="p">)</span>
<span class="n">demography</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div style="margin-left:20px"><div><style scoped="">
            .tskit-table thead tr th:only-of-type {vertical-align: middle;}
            .tskit-table thead tr th {text-align: center;vertical-align: top;}
            .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
            .tskit-table tbody th {padding: 0.5em 0.5em;}
        </style><b>Populations (3)</b><table border="1" class="tskit-table"><thead><tr><th>id</th><th>name</th><th>description</th><th>initial_size</th><th>growth_rate</th><th>default_sampling_time</th><th>extra_metadata</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>Contemporary population A</td><td>0.0</td><td>0</td><td>0</td><td>{}</td></tr><tr><td>1</td><td>B</td><td>Contemporary population B</td><td>0.0</td><td>0</td><td>0</td><td>{}</td></tr><tr><td>2</td><td>C</td><td>Ancestral population</td><td>0.0</td><td>0</td><td>0</td><td>{}</td></tr></tbody></table></div><div><style scoped="">
            .tskit-table thead tr th:only-of-type {vertical-align: middle;}
            .tskit-table thead tr th {text-align: center;vertical-align: top;}
            .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
            .tskit-table tbody th {padding: 0.5em 0.5em;}
        </style><b>Migration matrix (all zero)</b><table border="1" class="tskit-table"><thead><tr></tr></thead><tbody></tbody></table></div><div><style scoped="">
            .tskit-table thead tr th:only-of-type {vertical-align: middle;}
            .tskit-table thead tr th {text-align: center;vertical-align: top;}
            .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
            .tskit-table tbody th {padding: 0.5em 0.5em;}
        </style><b>Events (0)</b><table border="1" class="tskit-table"><thead><tr></tr></thead><tbody></tbody></table></div></div></div></div>
</div>
<p>We can see that the population names and descriptions have been recovered
from the tree sequence metadata but <strong>no other information</strong>: the
population sizes are all zero and we no longer have a population split
event. If we try to run a simulation using this demography we get an
error:</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="n">initial_state</span><span class="o">=</span><span class="n">ts1</span><span class="p">,</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">InputError</span><span class="g g-Whitespace">                                </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">60</span><span class="o">-</span><span class="n">e427bdafa23a</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="n">initial_state</span><span class="o">=</span><span class="n">ts1</span><span class="p">,</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">)</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">sim_ancestry</span><span class="nt">(samples, demography, sequence_length, discrete_genome, recombination_rate, gene_conversion_rate, gene_conversion_tract_length, population_size, ploidy, model, initial_state, start_time, end_time, record_migrations, record_full_arg, num_labels, random_seed, num_replicates, replicate_index, record_provenance)</span>
<span class="g g-Whitespace">   </span><span class="mi">1145</span>         <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
<span class="g g-Whitespace">   </span><span class="mi">1146</span>         <span class="n">provenance_dict</span> <span class="o">=</span> <span class="n">_build_provenance</span><span class="p">(</span><span class="s2">&quot;sim_ancestry&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
<span class="ne">-&gt; </span><span class="mi">1147</span>     <span class="n">sim</span> <span class="o">=</span> <span class="n">_parse_sim_ancestry</span><span class="p">(</span>
<span class="g g-Whitespace">   </span><span class="mi">1148</span>         <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1149</span>         <span class="n">sequence_length</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">_parse_sim_ancestry</span><span class="nt">(samples, sequence_length, recombination_rate, gene_conversion_rate, gene_conversion_tract_length, discrete_genome, population_size, demography, ploidy, model, initial_state, start_time, end_time, record_migrations, record_full_arg, num_labels, random_seed, init_for_debugger)</span>
<span class="g g-Whitespace">    </span><span class="mi">969</span>     <span class="n">random_generator</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">RandomGenerator</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">970</span> 
<span class="ne">--&gt; </span><span class="mi">971</span>     <span class="k">return</span> <span class="n">Simulator</span><span class="p">(</span>
<span class="g g-Whitespace">    </span><span class="mi">972</span>         <span class="n">tables</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
<span class="g g-Whitespace">    </span><span class="mi">973</span>         <span class="n">recombination_map</span><span class="o">=</span><span class="n">recombination_map</span><span class="p">,</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">__init__</span><span class="nt">(self, tables, recombination_map, gene_conversion_map, gene_conversion_tract_length, discrete_genome, ploidy, demography, random_generator, models, store_migrations, store_full_arg, start_time, end_time, num_labels)</span>
<span class="g g-Whitespace">   </span><span class="mi">1256</span> 
<span class="g g-Whitespace">   </span><span class="mi">1257</span>         <span class="n">start_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start_time</span>
<span class="ne">-&gt; </span><span class="mi">1258</span>         <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
<span class="g g-Whitespace">   </span><span class="mi">1259</span>             <span class="n">tables</span><span class="o">=</span><span class="n">ll_tables</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1260</span>             <span class="n">recombination_map</span><span class="o">=</span><span class="n">ll_recomb_map</span><span class="p">,</span>

<span class="ne">InputError</span>: Input error in initialise: Attempt to sample lineage in a population with size=0
</pre></div>
</div>
</div>
</div>
<p>To recover the original model we must update the <a class="reference internal" href="api.html#msprime.Population" title="msprime.Population"><code class="xref py py-class docutils literal notranslate"><span class="pre">Population</span></code></a>
objects in place and add the
<a class="reference internal" href="demography.html#sec-demography-events-population-split"><span class="std std-ref">population split</span></a> event:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">demography</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">demography</span><span class="p">[</span><span class="s2">&quot;C&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population_split</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">ancestral</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">derived</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">])</span>
<span class="n">demography</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div style="margin-left:20px"><div><style scoped="">
            .tskit-table thead tr th:only-of-type {vertical-align: middle;}
            .tskit-table thead tr th {text-align: center;vertical-align: top;}
            .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
            .tskit-table tbody th {padding: 0.5em 0.5em;}
        </style><b>Populations (3)</b><table border="1" class="tskit-table"><thead><tr><th>id</th><th>name</th><th>description</th><th>initial_size</th><th>growth_rate</th><th>default_sampling_time</th><th>extra_metadata</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>Contemporary population A</td><td>100.0</td><td>0</td><td>0</td><td>{}</td></tr><tr><td>1</td><td>B</td><td>Contemporary population B</td><td>200.0</td><td>0</td><td>0</td><td>{}</td></tr><tr><td>2</td><td>C</td><td>Ancestral population</td><td>300.0</td><td>0</td><td>1e+02</td><td>{}</td></tr></tbody></table></div><div><style scoped="">
            .tskit-table thead tr th:only-of-type {vertical-align: middle;}
            .tskit-table thead tr th {text-align: center;vertical-align: top;}
            .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
            .tskit-table tbody th {padding: 0.5em 0.5em;}
        </style><b>Migration matrix (all zero)</b><table border="1" class="tskit-table"><thead><tr></tr></thead><tbody></tbody></table></div><div><style scoped="">
            .tskit-table thead tr th:only-of-type {vertical-align: middle;}
            .tskit-table thead tr th {text-align: center;vertical-align: top;}
            .tskit-table tbody td {text-align: right;padding: 0.5em 0.5em;}
            .tskit-table tbody th {padding: 0.5em 0.5em;}
        </style><b>Events (1)</b><table border="1" class="tskit-table"><thead><tr><th>time</th><th>type</th><th>parameters</th><th>effect</th></tr></thead><tbody><tr><td>100</td><td><a href='https://tskit.dev/msprime/docs/latest/api.html#msprime.Demography.add_population_split'>Population Split</a></td><td>derived=[A, B], ancestral=C</td><td>Moves all lineages from derived populations &#x27;A&#x27; and &#x27;B&#x27; to the ancestral &#x27;C&#x27; population. Also set the derived populations to inactive, and all migration rates to and from the derived populations to zero.</td></tr></tbody></table></div></div></div></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See the <a class="reference internal" href="api.html#msprime.Demography" title="msprime.Demography"><code class="xref py py-class docutils literal notranslate"><span class="pre">Demography</span></code></a> documentation for details on how to access
<a class="reference internal" href="api.html#msprime.Population" title="msprime.Population"><code class="xref py py-class docutils literal notranslate"><span class="pre">Population</span></code></a> objects.</p>
</div>
<p>The demography that we obtain from <a class="reference internal" href="api.html#msprime.Demography.from_tree_sequence" title="msprime.Demography.from_tree_sequence"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Demography.from_tree_sequence()</span></code></a>
is really just a template, which we update and elaborate as we need.
In particular, we are free to add more populations as needed.</p>
</div>
<div class="section" id="continuing-forwards-time-simulations-recapitating">
<span id="sec-ancestry-initial-state-forward-simulations"></span><h3>Continuing forwards-time simulations (“recapitating”)<a class="headerlink" href="#continuing-forwards-time-simulations-recapitating" title="Permalink to this headline">¶</a></h3>
<p>The most common use for the <code class="docutils literal notranslate"><span class="pre">initial_state</span></code> argument is to
start the simulation from the output of a forwards-time simulation.
Informally, we take an ‘unfinished’
tree sequence as a parameter to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a>, initialise the simulation
from the state of this tree sequence and then run the simulation until
coalescence. The returned tree sequence is then the result of taking the
input tree sequence and completing the trees using the coalescent.</p>
<p>This is useful for forwards-time simulators such as
<a class="reference external" href="https://messerlab.org/slim/">SLiM</a> and
<a class="reference external" href="https://pypi.org/project/fwdpy11/">fwdpy11</a>
that can output tree sequences. By running
forward-time simulation for a certain number of generations we obtain a
tree sequence, but these trees may not have had sufficient time to
reach a most recent common ancestor. By using the <code class="docutils literal notranslate"><span class="pre">initial_state</span></code> argument
to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a> we can combine the best of both forwards- and
backwards-time simulators. The recent past can be simulated forwards
in time and the ancient past by the coalescent. The coalescent
simulation is initialised by the root segments of the
input tree sequence, ensuring that the minimal amount of ancestral
material possible is simulated.</p>
<p>Any tree sequence can be provided as input to this process, but there is a
specific topological requirement that must be met for the simulations to be
statistically correct. To ensure that ancestral segments are correctly
associated within chromosomes when constructing the initial conditions for the
coalescent simulation, forward-time simulators <strong>must</strong> retain the nodes
corresponding to the initial generation. Furthermore, for every sample in the
final generation (i.e. the extant population at the present time) there must be
a path to one of the founder population nodes.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the <a class="reference external" href="https://pyslim.readthedocs.io/en/stable/tutorial.html#sec-tutorial-recapitation" title="(in pyslim v0.600)"><span class="xref std std-ref">recapitation tutorial</span></a>
from the <a class="reference external" href="https://github.com/tskit-dev/pyslim">pyslim</a> documentation
for a detailed explanation of this process when
using <a class="reference external" href="https://messerlab.org/slim/">SLiM</a>.</p>
</div>
</div>
</div>
<div class="section" id="models">
<span id="sec-ancestry-models"></span><h2>Models<a class="headerlink" href="#models" title="Permalink to this headline">¶</a></h2>
<p>The ancestry model determines the model under which the ancestral
history of the sample is generated. It is concerned with the
the basic processes of how (for example) common ancestor and
recombination events occur. For example, the default
“standard” or <a class="reference internal" href="#sec-ancestry-models-hudson"><span class="std std-ref">Hudson coalescent</span></a> is an
efficient continuous time model, and the
<a class="reference internal" href="#sec-ancestry-models-dtwf"><span class="std std-ref">Discrete Time Wright-Fisher</span></a> model allows
for more detailed (if less efficient) simulations by
making fewer mathematical approximations.
We can combine multiple ancestry models in a simulation
using a flexible <a class="reference internal" href="#sec-ancestry-models-specifying"><span class="std std-ref">notation</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the <a class="reference internal" href="#sec-ancestry-quickref"><span class="std std-ref">Quick reference</span></a> for a summary of the available
ancestry models</p>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The ancestry model is distinct from the <a class="reference internal" href="demography.html#sec-demography"><span class="std std-ref">demographic model</span></a>,
which is mostly independent of the chosen ancestry model.</p>
</div>
<div class="section" id="specifying-ancestry-models">
<span id="sec-ancestry-models-specifying"></span><h3>Specifying ancestry models<a class="headerlink" href="#specifying-ancestry-models" title="Permalink to this headline">¶</a></h3>
<p>The ancestry models used during a simulation are specified using
the <code class="docutils literal notranslate"><span class="pre">model</span></code> parameter to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a>. Each model is a
subclass of the <a class="reference internal" href="api.html#msprime.AncestryModel" title="msprime.AncestryModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">AncestryModel</span></code></a> class (see the following
subsections for the available models, and examples of their usage).</p>
<div class="section" id="single-models">
<h4>Single models<a class="headerlink" href="#single-models" title="Permalink to this headline">¶</a></h4>
<p>Most of the time we want to run a simulation under a single
ancestry model. By default, we run simulations under the
<a class="reference internal" href="api.html#msprime.StandardCoalescent" title="msprime.StandardCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardCoalescent</span></code></a> model. If we wish to run
under a different model, we use the <code class="docutils literal notranslate"><span class="pre">model</span></code> argument to
<a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a>. For example, here we use the
<a class="reference internal" href="api.html#msprime.SmcApproxCoalescent" title="msprime.SmcApproxCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMC</span></code></a> model instead of the
standard coalescent:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts1</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">10</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">SmcApproxCoalescent</span><span class="p">(),</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We specify the model as an instance of one of the ancestry model classes.
For nonparametric models, there is also a useful shorthand
of the model name:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts2</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">10</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="s2">&quot;smc&quot;</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">ts1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">ts2</span><span class="p">,</span> <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This string form is useful for single model simulations;
however, when working with
<a class="reference internal" href="#sec-ancestry-models-specifying-multiple"><span class="std std-ref">Multiple models</span></a> it is better to use
the explicit class form so that the
<a class="reference internal" href="#sec-ancestry-models-specifying-duration"><span class="std std-ref">Model duration</span></a> can be set.</p>
</div>
<div class="section" id="model-duration">
<span id="sec-ancestry-models-specifying-duration"></span><h4>Model duration<a class="headerlink" href="#model-duration" title="Permalink to this headline">¶</a></h4>
<p>Each ancestry model instance has a <a class="reference internal" href="api.html#msprime.AncestryModel.duration" title="msprime.AncestryModel.duration"><code class="xref py py-attr docutils literal notranslate"><span class="pre">duration</span></code></a> associated
with it. This is the maximum amount of time that this model can run for. Thus,
if we wanted to run 10 generations of the <a class="reference internal" href="api.html#msprime.DiscreteTimeWrightFisher" title="msprime.DiscreteTimeWrightFisher"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeWrightFisher</span></code></a>
model we could write:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">DiscreteTimeWrightFisher</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_120_0.svg" src="_images/ancestry_120_0.svg" /></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using the duration value for a single model like this is identical to
specifying an <code class="docutils literal notranslate"><span class="pre">end_time</span></code> value: see the <a class="reference internal" href="#sec-ancestry-end-time"><span class="std std-ref">Stopping simulations early</span></a>
section for more information.</p>
</div>
<p>It is vital to understand that the <code class="docutils literal notranslate"><span class="pre">duration</span></code> value here is <strong>not</strong>
an absolute time at which the simulation must stop, but rather
the number of generations that the model should run for. To illustrate
this we can use the <a class="reference internal" href="#sec-ancestry-start-time"><span class="std std-ref">start_time</span></a> parameter:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">DiscreteTimeWrightFisher</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_122_0.svg" src="_images/ancestry_122_0.svg" /></div>
</div>
<p>We can see that the simulation continued until 15 generations ago,
because it didn’t start until 5 generations ago and we then specified
that the model should run for at most 10 generations.</p>
<p>The model activity time is specified as a duration in this way
as this is a natural way to specify
<a class="reference internal" href="#sec-ancestry-models-specifying-multiple"><span class="std std-ref">Multiple models</span></a>, in which
some of the models may run for random periods of time.</p>
</div>
<div class="section" id="model-completion">
<span id="sec-ancestry-models-specifying-completion"></span><h4>Model completion<a class="headerlink" href="#model-completion" title="Permalink to this headline">¶</a></h4>
<p>Most ancestry models will run until the overall simulation has
completed; that is, when we have simulated back to the most
recent common ancestor at every position along the sequence.
For example, the <a class="reference internal" href="api.html#msprime.StandardCoalescent" title="msprime.StandardCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardCoalescent</span></code></a> and
<a class="reference internal" href="api.html#msprime.DiscreteTimeWrightFisher" title="msprime.DiscreteTimeWrightFisher"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeWrightFisher</span></code></a> models will simulate
until coalescence, unless we explicitly indicate that we wish
to stop the simulation early via the
<a class="reference internal" href="#sec-ancestry-models-specifying-duration"><span class="std std-ref">model duration</span></a>
or the <a class="reference internal" href="#sec-ancestry-end-time"><span class="std std-ref">end_time</span></a> parameter.</p>
<p>Models such as <a class="reference internal" href="api.html#msprime.SweepGenicSelection" title="msprime.SweepGenicSelection"><code class="xref py py-class docutils literal notranslate"><span class="pre">SweepGenicSelection</span></code></a> are different though:
they are only defined for a limited amount of time and
may not run until coalescence (see the
<a class="reference internal" href="#sec-ancestry-models-selective-sweeps"><span class="std std-ref">Selective sweeps</span></a>
for more information on the model itself).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sweep</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">SweepGenicSelection</span><span class="p">(</span>
    <span class="n">position</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">start_frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">end_frequency</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
    <span class="n">s</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
    <span class="n">dt</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">sweep</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_124_0.svg" src="_images/ancestry_124_0.svg" /></div>
</div>
<p>Here, we see that even though we didn’t specify
a <a class="reference internal" href="#sec-ancestry-models-specifying-duration"><span class="std std-ref">model duration</span></a>
or <a class="reference internal" href="#sec-ancestry-end-time"><span class="std std-ref">end_time</span></a> parameter the simulation
has ended before we reached coalescence. In addition, the
model duration is <strong>random</strong>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">3</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">sweep</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">12345</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_126_0.svg" src="_images/ancestry_126_0.svg" /></div>
</div>
<p>Here we ran the same simulation with a different random seed, and
we can see that the time the model completed was different in
the two cases (30.22 vs 28.15 generations ago).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Models such as <a class="reference internal" href="api.html#msprime.SweepGenicSelection" title="msprime.SweepGenicSelection"><code class="xref py py-class docutils literal notranslate"><span class="pre">SweepGenicSelection</span></code></a> can also complete due
to full coalescence.</p>
</div>
</div>
<div class="section" id="multiple-models">
<span id="sec-ancestry-models-specifying-multiple"></span><h4>Multiple models<a class="headerlink" href="#multiple-models" title="Permalink to this headline">¶</a></h4>
<p>Sometimes we are interested in combining different models in a simulation.
To do this we provide a <strong>list</strong> of ancestry model instances as the
<code class="docutils literal notranslate"><span class="pre">model</span></code> argument to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a>. The models
are run in the order they are specified. For each model, if its
<a class="reference internal" href="api.html#msprime.AncestryModel.duration" title="msprime.AncestryModel.duration"><code class="xref py py-attr docutils literal notranslate"><span class="pre">duration</span></code></a> is set, then the simulation will run
for at most that additional time duration. If the <code class="docutils literal notranslate"><span class="pre">duration</span></code> is
not set (or <code class="docutils literal notranslate"><span class="pre">None</span></code>), then the model will run until
<a class="reference internal" href="#sec-ancestry-models-specifying-completion"><span class="std std-ref">completion</span></a>.</p>
<p>For example, here we run a hybrid DTWF and coalescent
simulation (see the <a class="reference internal" href="#sec-ancestry-models-dtwf"><span class="std std-ref">Discrete Time Wright-Fisher</span></a> section for more
details):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">DiscreteTimeWrightFisher</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">500</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">StandardCoalescent</span><span class="p">(),</span>
    <span class="p">],</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is very imporant to remember to set a <code class="docutils literal notranslate"><span class="pre">duration</span></code> value in the first
model here! Otherwise, the entire simulation will run under the DTWF model.</p>
</div>
<p>In this example we’ve run the <a class="reference internal" href="api.html#msprime.DiscreteTimeWrightFisher" title="msprime.DiscreteTimeWrightFisher"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeWrightFisher</span></code></a>
model for the first 500 generations, and then switched to the
<a class="reference internal" href="api.html#msprime.StandardCoalescent" title="msprime.StandardCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">StandardCoalescent</span></code></a>. Because we did not specify a
<code class="docutils literal notranslate"><span class="pre">duration</span></code> in the second model, it will run until coalescence.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Switching models at a fixed time point like this is equivalent to
first running the DTWF phase of the simulation with <code class="docutils literal notranslate"><span class="pre">end_time=500</span></code>
and then using the output as the
<a class="reference internal" href="#sec-ancestry-initial-state"><span class="std std-ref">initial state</span></a> for the simulation
of the Hudson phase. The model switching syntax here is a little
more convenient and efficient, however.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the <a class="reference internal" href="#sec-ancestry-models-selective-sweeps-multiple"><span class="std std-ref">Multiple sweeps</span></a> section for
an example of running many models with random durations.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The logging output of msprime can be very useful when working with
multiple models. See the <a class="reference internal" href="logging.html#sec-logging"><span class="std std-ref">Logging</span></a> section for more
details.</p>
</div>
</div>
</div>
<div class="section" id="hudson-coalescent">
<span id="sec-ancestry-models-hudson"></span><h3>Hudson coalescent<a class="headerlink" href="#hudson-coalescent" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="api.html#msprime.StandardCoalescent" title="msprime.StandardCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">standard</span> <span class="pre">coalescent</span></code></a>
is the default model in msprime. The algorithm
for simulating the coalescent with recombination was developed
by <a class="reference external" href="https://doi.org/10.1016/0040-5809(83)90013-8">Hudson (1983)</a>,
and so we refer to it as the “Hudson” coalescent.</p>
<p>Running a simulation without specifying a <code class="docutils literal notranslate"><span class="pre">model</span></code> is the
same as running with <code class="docutils literal notranslate"><span class="pre">model=&quot;hudson&quot;</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts1</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ts2</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;hudson&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># This is the same simulation so tree sequences are equal</span>
<span class="k">assert</span> <span class="n">ts1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">ts2</span><span class="p">,</span> <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Time is measured in units of generations ago. This is a continuous time
model, in which the simulation moves event-by-event backwards
in time (contrasting with the <a class="reference internal" href="#sec-ancestry-models-dtwf"><span class="std std-ref">Discrete Time Wright-Fisher</span></a> model, which
works generation-by-generation). Thus, we can have fractional
generations, as in this example where the MRCA of the sample
occurs 10.59 “generations” ago:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">234</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_132_0.svg" src="_images/ancestry_132_0.svg" /></div>
</div>
<p>This occurs because time is scaled to be proportional to
the population size; if we run the same simulation with a
different <a class="reference internal" href="#sec-ancestry-demography"><span class="std std-ref">population size</span></a>, we can see that
the time values are simply scaled up accordingly
(the default <code class="docutils literal notranslate"><span class="pre">population_size</span></code> is 1):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">234</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_134_0.svg" src="_images/ancestry_134_0.svg" /></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The <a class="reference internal" href="#sec-ancestry-ploidy"><span class="std std-ref">ploidy</span></a> parameter also controls
the time scale; the
default here is the diploid time scale where time is measured
in units of 4N generations.</p>
</div>
</div>
<div class="section" id="smc-approximations">
<span id="sec-ancestry-models-smc"></span><h3>SMC approximations<a class="headerlink" href="#smc-approximations" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="api.html#msprime.SmcApproxCoalescent" title="msprime.SmcApproxCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMC</span></code></a> and <a class="reference internal" href="api.html#msprime.SmcPrimeApproxCoalescent" title="msprime.SmcPrimeApproxCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMC'</span></code></a>
are approximations of the continuous time
<a class="reference internal" href="#sec-ancestry-models-hudson"><span class="std std-ref">Hudson coalescent</span></a> model. These were originally
motivated largely by the need to simulate coalescent processes more efficiently
than was possible using the software available at the time; however,
<a class="reference external" href="https://doi.org/10.1371/journal.pcbi.1004842">improved algorithms</a>
mean that such approximations are now mostly unnecessary for simulations.</p>
<p>The SMC and SMC’ are however very important for inference, as the approximations
have made many analytical advances possible.</p>
<p>Since the SMC approximations are not required for simulation efficiency, these
models are implemented using a naive rejection sampling approach in msprime.
The implementation is intended to facilitate the study of the
SMC approximations, rather than to be used in a general-purpose way.</p>
</div>
<div class="section" id="discrete-time-wright-fisher">
<span id="sec-ancestry-models-dtwf"></span><h3>Discrete Time Wright-Fisher<a class="headerlink" href="#discrete-time-wright-fisher" title="Permalink to this headline">¶</a></h3>
<p>Msprime provides the option to perform discrete-time Wright-Fisher (DTWF)
simulations for scenarios when the coalescent model is not appropriate, including large
sample sizes, multiple chromosomes, or recent migration.
Please see the <a class="reference internal" href="api.html#msprime.DiscreteTimeWrightFisher" title="msprime.DiscreteTimeWrightFisher"><code class="xref py py-class docutils literal notranslate"><span class="pre">API</span> <span class="pre">documentation</span></code></a>
for a formal description of the model,
and <a class="reference external" href="https://doi.org/10.1371/journal.pgen.1008619">Nelson et al. 2020</a> for
more details and background information.</p>
<p>To run DTWF simulations, we need to provide the <code class="docutils literal notranslate"><span class="pre">model=&quot;dtwf&quot;</span></code> argument
to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;dtwf&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tree_height_scale</span><span class="o">=</span><span class="s2">&quot;log_time&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_136_0.svg" src="_images/ancestry_136_0.svg" /></div>
</div>
<p>There are a few important points to note here:</p>
<ol class="simple">
<li><p>All node times are integers (this is discrete time counted in generations);</p></li>
<li><p>We can have <strong>non-binary</strong> nodes (see node 10);</p></li>
<li><p>We can have <strong>simultaneous</strong> events (see nodes 8 and 9).</p></li>
</ol>
<p>Most features can be used with the DTWF model, and an error will be raised if
you attempt to use a feature that is not implemented for DTWF. (Please let
us know if this feature is important to you!)</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>For DTWF simulations with population structure, each row of the migration
matrix must sum to one or less.</p>
</div>
<p>Because DTWF simulations trace the history of a sample by going backwards
in time generation-by-generation rather than event-by-event like the
continuous time models, it is significantly slower to simulate than
the standard coalescent.</p>
<p>“Hybrid” simulations can be a good solution if DTWF simulations are
slow. In this case we can use DTWF simulations for the recent past, and using
the standard coalescent for the more distant past (where it is an excellent
approximation of the discrete time model). Hybrid simulations
of this type provide the best of computational efficiency and accuracy.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See <a class="reference external" href="https://doi.org/10.1371/journal.pgen.1008619">Nelson et al. 2020</a> for
more details and examples where the DTWF model is more realistic than
the coalescent, and an assessment of the accuracy of hybrid simulations.</p>
</div>
<p>For example, here we simulate with the DTWF model for 500 generations,
before switching to the standard (Hudson) coalescent:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="p">[</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">DiscreteTimeWrightFisher</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">500</span><span class="p">),</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">StandardCoalescent</span><span class="p">(),</span>
    <span class="p">],</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">4</span>
<span class="p">)</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="n">y_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tree_height_scale</span><span class="o">=</span><span class="s2">&quot;log_time&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_138_0.svg" src="_images/ancestry_138_0.svg" /></div>
</div>
<p>Because of the integer node times, we can see here that most of the coalescent
happened during the Wright-Fisher phase of the simulation, and as-of 500
generations in the past, there were only two lineages left. The continuous
time standard coalescent model was then used to simulate the ancient past of
these two lineages.</p>
<p>See the <a class="reference internal" href="#sec-ancestry-models-specifying"><span class="std std-ref">Specifying ancestry models</span></a> section for more details on
how the use the <code class="docutils literal notranslate"><span class="pre">model</span></code> argument to <a class="reference internal" href="api.html#msprime.sim_ancestry" title="msprime.sim_ancestry"><code class="xref py py-func docutils literal notranslate"><span class="pre">sim_ancestry()</span></code></a> to run
multiple models.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the <a class="reference internal" href="#sec-ancestry-multiple-chromosomes"><span class="std std-ref">Multiple chromosomes</span></a> section for information
on how to simulate multiple chromosomes using the DTWF.</p>
</div>
</div>
<div class="section" id="multiple-merger-coalescents">
<span id="sec-ancestry-models-multiple-mergers"></span><h3>Multiple merger coalescents<a class="headerlink" href="#multiple-merger-coalescents" title="Permalink to this headline">¶</a></h3>
<p>Some evolutionary scenarios, such as a skewed offspring distribution
combined with a type III survivorship curve, range expansion, and
rapid adaptation, can predict genealogies with up to four simultaneous
multiple mergers. Msprime provides the option to simulate from two classes
of such genealogical processes: the <a class="reference internal" href="api.html#msprime.BetaCoalescent" title="msprime.BetaCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">BetaCoalescent</span></code></a> and
the <a class="reference internal" href="api.html#msprime.DiracCoalescent" title="msprime.DiracCoalescent"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiracCoalescent</span></code></a>. Please see the API documentation for formal
details of the models.</p>
<p>For haploid organisms, both models result in genealogies in which
any number of lineages can merge into a common ancestor,
but only one merger event can take place at a given time. For <span class="math notranslate nohighlight">\(p\)</span>-ploids,
up to <span class="math notranslate nohighlight">\(2p\)</span> simultaneous mergers can take place, corresponding to the
<span class="math notranslate nohighlight">\(2p\)</span> available parental chromosome copies.</p>
<p>The diploid Beta-Xi-coalescent can be simulated as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">BetaCoalescent</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.001</span><span class="p">))</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_140_0.svg" src="_images/ancestry_140_0.svg" /></div>
</div>
<p>The specified value of <span class="math notranslate nohighlight">\(\alpha = 1.001\)</span> corresponds to a heavily skewed
offspring distribution. Values closer to <span class="math notranslate nohighlight">\(\alpha = 2\)</span> result in trees
whose distribution is closer to that of the standard coalescent, often featuring
no multiple mergers for small sample sizes:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">BetaCoalescent</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.8</span><span class="p">))</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_142_0.svg" src="_images/ancestry_142_0.svg" /></div>
</div>
<p>Multiple mergers still take place in a haploid simulation, but only one merger
can take place at a given time:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">BetaCoalescent</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.001</span><span class="p">))</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_144_0.svg" src="_images/ancestry_144_0.svg" /></div>
</div>
<p>A haploid simulation results in larger individual mergers than a polyploid simulation
because large mergers typically get broken up into multiple simultaneous mergers
in the polyploid model.</p>
<p>The number of generations between merger events in the Beta-coalescent depends
nonlinearly on both <span class="math notranslate nohighlight">\(\alpha\)</span> and the population size <span class="math notranslate nohighlight">\(N\)</span>
as detailed above.
For a fixed <span class="math notranslate nohighlight">\(\alpha\)</span>, the number of generations between common ancestor events
is proportional to <span class="math notranslate nohighlight">\(N^{\alpha - 1}\)</span>, albeit with a complicated constant of
proportionality that depends on <span class="math notranslate nohighlight">\(\alpha\)</span>. The dependence on <span class="math notranslate nohighlight">\(\alpha\)</span>
for fixed <span class="math notranslate nohighlight">\(N\)</span> is not monotone. Thus, branch lengths and the number of
generations until a most recent common ancestor depend on both of these parameters.</p>
<p>To illustrate, for <span class="math notranslate nohighlight">\(\alpha\)</span> close to 2 the relationship between effective
population size and number of generations is almost linear:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">BetaCoalescent</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.99</span><span class="p">))</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">tmrca</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">BetaCoalescent</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.99</span><span class="p">))</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">tmrca</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.14959691919068155
14.286394871874865
</pre></div>
</div>
</div>
</div>
<p>For <span class="math notranslate nohighlight">\(\alpha\)</span> close to 1 the effective population size has little effect:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">BetaCoalescent</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.1</span><span class="p">))</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">tmrca</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">BetaCoalescent</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.1</span><span class="p">))</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">tmrca</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>16.311807036386615
25.85247192870844
</pre></div>
</div>
</div>
</div>
<p>The Dirac-coalescent is simulated similarly in both the diploid case:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">DiracCoalescent</span><span class="p">(</span><span class="n">psi</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_150_0.svg" src="_images/ancestry_150_0.svg" /></div>
</div>
<p>and in the haploid case:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">DiracCoalescent</span><span class="p">(</span><span class="n">psi</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="n">SVG</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_152_0.svg" src="_images/ancestry_152_0.svg" /></div>
</div>
<p>As with the Beta-coalescent, a haploid simulation results in larger individual
mergers than a polyploid simulation because large mergers typically get broken
up into multiple simultaneous mergers in the polyploid model. Larger values
of the parameter <span class="math notranslate nohighlight">\(c &gt; 0\)</span> result in more frequent multiple mergers,
while larger values of <span class="math notranslate nohighlight">\(0 &lt; \psi \leq 1\)</span> result in multiple mergers
with more participating lineages. Setting either parameter to 0 would correspond
to the standard coalescent.</p>
<p>The Dirac-coalescent is obtained as the infinite population scaling limit of
Moran models, and therefore branch lengths are proportional to <span class="math notranslate nohighlight">\(N^2\)</span>
generations, as opposed to <span class="math notranslate nohighlight">\(N\)</span> generations under the standard coalescent.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">DiracCoalescent</span><span class="p">(</span><span class="n">psi</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">tmrca</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">msprime</span><span class="o">.</span><span class="n">DiracCoalescent</span><span class="p">(</span><span class="n">psi</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">tmrca</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>64.7216732891741
6472.167328917411
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="selective-sweeps">
<span id="sec-ancestry-models-selective-sweeps"></span><h3>Selective sweeps<a class="headerlink" href="#selective-sweeps" title="Permalink to this headline">¶</a></h3>
<p>Although the coalescent assumes that lineages are exchangable, (and therefore
evolving neutrally), approximations to some forms of selective sweep
(beneficial mutation moves through the population), have been derived. This is
done through the use of a structured coalescent model in the spirit of
<a class="reference external" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1206652/">Braverman et al. (1995)</a>.</p>
<p>In the <a class="reference internal" href="api.html#msprime.SweepGenicSelection" title="msprime.SweepGenicSelection"><code class="xref py py-class docutils literal notranslate"><span class="pre">SweepGenicSelection</span></code></a> model,
the population is split between two classes of selective backgrounds,
those linked to the beneficial allele, call it <span class="math notranslate nohighlight">\(B\)</span>, and those not,
<span class="math notranslate nohighlight">\(b\)</span>. In this model we track competing
rates of coalescence and recombination on the <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(b\)</span>
backgrounds.
The user supplies a final allele frequency and a starting
allele frequency, between which msprime simulates a stochastic
sweep trajectory according to a conditional diffusion model <a class="reference external" href="https://pubmed.ncbi.nlm.nih.gov/15465123/">(Coop
and Griffiths, 2004</a>;
<a class="reference external" href="https://pubmed.ncbi.nlm.nih.gov/11861577/">Kim and Stephan 2002</a>).</p>
<p>Beyond the start and end frequencies of the sweep trajectory, the user
must specify the selection coefficient of the beneficial mutation
<span class="math notranslate nohighlight">\(s\)</span> the selective
advantage of the <span class="math notranslate nohighlight">\(B\)</span> homozygote over the <span class="math notranslate nohighlight">\(b\)</span> homozygote
and <span class="math notranslate nohighlight">\(h=0.5\)</span>. The position represents the location along
the chromosome where the beneficial allele occurs.
All other parameters can be set as usual.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The implementation of the structured coalescent is quite general, but there are
some limitations in the current implementation of the sweeps model (e.g., no
change of population size during a sweep). Please let us know if there are
related features you would like to see (or if you would be interested in
helping to create this functionality!)</p>
</div>
<div class="section" id="hard-sweeps">
<h4>Hard sweeps<a class="headerlink" href="#hard-sweeps" title="Permalink to this headline">¶</a></h4>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>What’s a hard sweep? Some intro sentences here.</p>
</div>
<p>In this example we run some replicate hard sweep simulations
and plot the mean
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.diversity" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pairwise</span> <span class="pre">diversity</span></code></a> in windows
across the simulated region, showing the characteristic
valley of diversity.</p>
<p>First we set up some basic parameters, and define the sweep model:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Ne</span> <span class="o">=</span> <span class="mf">1e3</span>
<span class="n">L</span> <span class="o">=</span> <span class="mf">1e6</span>  <span class="c1"># Length of simulated region</span>
<span class="n">num_reps</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># define hard sweep model</span>
<span class="n">sweep_model</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">SweepGenicSelection</span><span class="p">(</span>
    <span class="n">position</span><span class="o">=</span><span class="n">L</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1"># middle of chrom</span>
    <span class="n">start_frequency</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Ne</span><span class="p">),</span>
    <span class="n">end_frequency</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Ne</span><span class="p">)),</span>
    <span class="n">s</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
    <span class="n">dt</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>Explain why these parameters give a hard sweep.</p>
</div>
<p>Next we set up the replicate simulations. As described
in the <a class="reference internal" href="#sec-ancestry-models-specifying-multiple"><span class="std std-ref">Multiple models</span></a> section,
the <code class="docutils literal notranslate"><span class="pre">model</span></code> parameter is a list when we want to run multiple
ancestry models. In this example, we have a sweep that occurs
in the immediate past, and is then followed by the
standard coalescent for the rest of time:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">reps</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">5</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="p">[</span><span class="n">sweep_model</span><span class="p">,</span> <span class="n">msprime</span><span class="o">.</span><span class="n">StandardCoalescent</span><span class="p">()],</span>
    <span class="n">population_size</span><span class="o">=</span><span class="n">Ne</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
    <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_reps</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because the <a class="reference internal" href="api.html#msprime.SweepGenicSelection" title="msprime.SweepGenicSelection"><code class="xref py py-class docutils literal notranslate"><span class="pre">SweepGenicSelection</span></code></a> model has a random
<a class="reference internal" href="#sec-ancestry-models-specifying-duration"><span class="std std-ref">duration</span></a> we do
not set this value in the model. Please see the
<a class="reference internal" href="#sec-ancestry-models-specifying-completion"><span class="std std-ref">Model completion</span></a> section for
more discussion on this important point.</p>
</div>
<p>Once we’ve set up the replicate simulations we can compute the
windows for plotting, run the actual simulations
(see the <a class="reference internal" href="replication.html#sec-randomness-replication"><span class="std std-ref">Running replicate simulations</span></a> section for more details)
and compute the
<a class="reference external" href="https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.diversity" title="(in tskit v0.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pairwise</span> <span class="pre">diversity</span></code></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">wins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
<span class="n">mids</span> <span class="o">=</span> <span class="p">(</span><span class="n">wins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">wins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">diversity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_reps</span><span class="p">,</span> <span class="n">mids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
    <span class="n">diversity</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">diversity</span><span class="p">(</span><span class="n">windows</span><span class="o">=</span><span class="n">wins</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;branch&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we can plot the observed mean diversity across the replicates
and compare it to the neutral expectation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mids</span><span class="p">,</span> <span class="n">diversity</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Simulations&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">Ne</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;Neutral expectation&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Branch $\pi$&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Position (bp)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ancestry_162_0.png" src="_images/ancestry_162_0.png" />
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use the “branch” measure of pairwise diversity which is
defined in terms of the trees rather than nucleotide sequences. See
<a class="reference external" href="https://doi.org/10.1534/genetics.120.303253">Ralph et al. 2020</a>
for more information.</p>
</div>
<p>As we can see, the selective sweep has reduced variation in the region
most closely linked to the beneficial allele and then diversity
increases with distance to each side.</p>
</div>
<div class="section" id="multiple-sweeps">
<span id="sec-ancestry-models-selective-sweeps-multiple"></span><h4>Multiple sweeps<a class="headerlink" href="#multiple-sweeps" title="Permalink to this headline">¶</a></h4>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>This example is very artificial; it would be much better to illustrate
with a meaningful example from the literature. Pull requests welcome!</p>
</div>
<p>To illustrate the idea that we can simulate large numbers of different
models, in this example we create a simulation in which we have
sweeps happening at random points along the genome, which
are separated by a random duration of the standard coalescent.</p>
<p>First we set up our models:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="mi">100</span>

<span class="n">models</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msprime</span><span class="o">.</span><span class="n">StandardCoalescent</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">msprime</span><span class="o">.</span><span class="n">SweepGenicSelection</span><span class="p">(</span>
            <span class="n">position</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">start_frequency</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
            <span class="n">end_frequency</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">s</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
            <span class="n">dt</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msprime</span><span class="o">.</span><span class="n">StandardCoalescent</span><span class="p">())</span>
<span class="n">models</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[StandardCoalescent(duration=0.9664535356921388),
 SweepGenicSelection(duration=None, position=57, start_frequency=0.4, end_frequency=0.5, s=0.01, dt=1e-06),
 StandardCoalescent(duration=0.11685051774599753),
 SweepGenicSelection(duration=None, position=12, start_frequency=0.4, end_frequency=0.5, s=0.01, dt=1e-06),
 StandardCoalescent(duration=0.9109759624491242)]
</pre></div>
</div>
</div>
</div>
<p>We’ve created a list of models that have random parameters using the
standard Python tools. There are lots of sweeps (many more than we
will actually run, in all probability), each at a random position
on the genome and each separated by a random amount of time running
the standard coalescent. Finally, we add an instance of the standard
coalescent without a <a class="reference internal" href="#sec-ancestry-models-specifying-duration"><span class="std std-ref">duration</span></a>
to guarantee that our simulation will always coalesce fully
(See the <a class="reference internal" href="#sec-ancestry-models-specifying-completion"><span class="std std-ref">Model completion</span></a> section
for more information.) Finally, we print out the first 5 models
so we can inspect them.</p>
<p>Then, we can run our simulation as usual:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span>
    <span class="mi">10</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="n">models</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">6789</span>
<span class="p">)</span>
<span class="n">ts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
<div>
  <style>
    .tskit-table thead tr th {text-align: left;padding: 0.5em 0.5em;}
    .tskit-table tbody tr td {padding: 0.5em 0.5em;}
    .tskit-table tbody tr td:first-of-type {text-align: left;}
    .tskit-details-label {vertical-align: top; padding-right:5px;}
    .tskit-table-set {display: inline-flex;flex-wrap: wrap;margin: -12px 0 0 -12px;width: calc(100% + 12px);}
    .tskit-table-set-table {margin: 12px 0 0 12px;}
    details {display: inline-block;}
    summary {cursor: pointer; outline: 0; display: list-item;}
  </style>
  <div class="tskit-table-set">
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="padding:0;line-height:21px;">
              <img style="height: 32px;display: inline-block;padding: 3px 5px 3px 0;"src="https://raw.githubusercontent.com/tskit-dev/administrative/main/tskit_logo.svg"/>
              <a target="_blank" href="https://tskit.readthedocs.io/en/latest/python-api.html#the-treesequence-class"> Tree Sequence
            </th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Trees</td><td>100</td></tr>
          <tr><td>Sequence Length</td><td>100.0</td></tr>
          <tr><td>Sample Nodes</td><td>20</td></tr>
          <tr><td>Total Size</td><td>95.0 KiB</td></tr>
          <tr>
            <td>Metadata</td><td style="text-align: left;">No Metadata</td></tr>
        </tbody>
      </table>
    </div>
    <div class="tskit-table-set-table">
      <table class="tskit-table">
        <thead>
          <tr>
            <th style="line-height:21px;">Table</th>
            <th>Rows</th>
            <th>Size</th>
            <th>Has Metadata</th>
          </tr>
        </thead>
        <tbody>

      <tr>
        <td>Edges</td>
          <td>1626</td>
          <td>44.5 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Individuals</td>
          <td>10</td>
          <td>172 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Migrations</td>
          <td>0</td>
          <td>4 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Mutations</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Nodes</td>
          <td>533</td>
          <td>12.5 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Populations</td>
          <td>1</td>
          <td>216 Bytes</td>
          <td style="text-align: center;">
            ✅
          </td>
        </tr>

      <tr>
        <td>Provenances</td>
          <td>1</td>
          <td>24.9 KiB</td>
          <td style="text-align: center;">

          </td>
        </tr>

      <tr>
        <td>Sites</td>
          <td>0</td>
          <td>8 Bytes</td>
          <td style="text-align: center;">

          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>
</div>
</div></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The logging output of msprime can be very useful when working with
multiple models. See the <a class="reference internal" href="logging.html#sec-logging"><span class="std std-ref">Logging</span></a> section for more
details.</p>
</div>
</div>
</div>
</div>
<div class="section" id="missing-data">
<span id="sec-ancestry-missing-data"></span><h2>Missing data<a class="headerlink" href="#missing-data" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<p>Give an example of doing a simulation with unknown rates on the flanks
and show that the resulting tree sequence has missing data in these
regions.</p>
</div>
</div>
<div class="section" id="common-errors">
<span id="sec-ancestry-errors"></span><h2>Common errors<a class="headerlink" href="#common-errors" title="Permalink to this headline">¶</a></h2>
<div class="section" id="infinite-waiting-time">
<span id="sec-ancestry-errors-infinite-waiting-time"></span><h3>Infinite waiting time<a class="headerlink" href="#infinite-waiting-time" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>explain this, why it happens and give examples of when
we don’t detect it. Mention the possible_lineage_locations method.</p>
</div>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">demography</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">Demography</span><span class="p">()</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">LibraryError</span><span class="g g-Whitespace">                              </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">88</span><span class="o">-</span><span class="mi">617</span><span class="n">bafbb05d4</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="n">demography</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="ne">----&gt; </span><span class="mi">4</span> <span class="n">msprime</span><span class="o">.</span><span class="n">sim_ancestry</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">)</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">sim_ancestry</span><span class="nt">(samples, demography, sequence_length, discrete_genome, recombination_rate, gene_conversion_rate, gene_conversion_tract_length, population_size, ploidy, model, initial_state, start_time, end_time, record_migrations, record_full_arg, num_labels, random_seed, num_replicates, replicate_index, record_provenance)</span>
<span class="g g-Whitespace">   </span><span class="mi">1164</span>         <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1165</span>     <span class="p">)</span>
<span class="ne">-&gt; </span><span class="mi">1166</span>     <span class="k">return</span> <span class="n">_wrap_replicates</span><span class="p">(</span>
<span class="g g-Whitespace">   </span><span class="mi">1167</span>         <span class="n">sim</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1168</span>         <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">,</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">_wrap_replicates</span><span class="nt">(simulator, num_replicates, replicate_index, provenance_dict, mutation_rate)</span>
<span class="g g-Whitespace">    </span><span class="mi">671</span>     <span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">672</span>     <span class="k">if</span> <span class="n">replicate_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="ne">--&gt; </span><span class="mi">673</span>         <span class="n">deque</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">674</span>         <span class="k">return</span> <span class="n">deque</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="g g-Whitespace">    </span><span class="mi">675</span>     <span class="k">else</span><span class="p">:</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">run_replicates</span><span class="nt">(self, num_replicates, mutation_rate, provenance_dict)</span>
<span class="g g-Whitespace">   </span><span class="mi">1435</span>         <span class="k">for</span> <span class="n">replicate_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_replicates</span><span class="p">):</span>
<span class="g g-Whitespace">   </span><span class="mi">1436</span>             <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting replicate </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">replicate_index</span><span class="p">)</span>
<span class="ne">-&gt; </span><span class="mi">1437</span>             <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="g g-Whitespace">   </span><span class="mi">1438</span>             <span class="k">if</span> <span class="n">mutation_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="g g-Whitespace">   </span><span class="mi">1439</span>                 <span class="c1"># This is only called from simulate() or the ms interface,</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">run</span><span class="nt">(self, event_chunk, debug_func)</span>
<span class="g g-Whitespace">   </span><span class="mi">1400</span>                 <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Model durations must be &gt;= 0&quot;</span><span class="p">)</span>
<span class="g g-Whitespace">   </span><span class="mi">1401</span>             <span class="n">end_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="n">model_duration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>
<span class="ne">-&gt; </span><span class="mi">1402</span>             <span class="n">exit_reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_until</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="p">,</span> <span class="n">debug_func</span><span class="p">)</span>
<span class="g g-Whitespace">   </span><span class="mi">1403</span>             <span class="k">if</span> <span class="n">exit_reason</span> <span class="o">==</span> <span class="n">ExitReason</span><span class="o">.</span><span class="n">COALESCENCE</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span>
<span class="g g-Whitespace">   </span><span class="mi">1404</span>                 <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping remaining </span><span class="si">%d</span><span class="s2"> models&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="nn">~/work/tskit-site/tskit-site/msprime/ancestry.py</span> in <span class="ni">_run_until</span><span class="nt">(self, end_time, event_chunk, debug_func)</span>
<span class="g g-Whitespace">   </span><span class="mi">1365</span>         <span class="n">ret</span> <span class="o">=</span> <span class="n">ExitReason</span><span class="o">.</span><span class="n">MAX_EVENTS</span>
<span class="g g-Whitespace">   </span><span class="mi">1366</span>         <span class="k">while</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">ExitReason</span><span class="o">.</span><span class="n">MAX_EVENTS</span><span class="p">:</span>
<span class="ne">-&gt; </span><span class="mi">1367</span>             <span class="n">ret</span> <span class="o">=</span> <span class="n">ExitReason</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="p">))</span>
<span class="g g-Whitespace">   </span><span class="mi">1368</span>             <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">end_time</span><span class="p">:</span>
<span class="g g-Whitespace">   </span><span class="mi">1369</span>                 <span class="c1"># Currently the Pedigree and Sweeps models are &quot;non-rentrant&quot;</span>

<span class="ne">LibraryError</span>: Infinite waiting time until next simulation event.
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="installation.html" title="previous page">Installation</a>
    <a class='right-next' id="next-link" href="mutations.html" title="next page">Mutation simulations</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Tskit Developers<br/>
        
            &copy; Copyright 2021.<br/>
          <div class="extra_footer">
            msprime 1.0.1
          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>